---
title: "NumPy 快速入门"
author: "黄湘云"
date: '2025-10-17'
slug: numpy
categories:
  - 统计软件
tags:
  - numpy
  - matrix
  - array
output:
  blogdown::html_page:
    toc: true
    number_sections: true
link-citations: true
description: "Python 模块 NumPy 是做数组操作的，本文添加等价 R 代码。"
---


<div id="TOC">
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80" id="toc-基础"><span class="toc-section-number">1</span> 基础</a>
<ul>
<li><a href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90" id="toc-一个例子"><span class="toc-section-number">1.1</span> 一个例子</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84" id="toc-创建数组"><span class="toc-section-number">1.2</span> 创建数组</a></li>
<li><a href="#%E6%89%93%E5%8D%B0%E6%95%B0%E7%BB%84" id="toc-打印数组"><span class="toc-section-number">1.3</span> 打印数组</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" id="toc-基本操作"><span class="toc-section-number">1.4</span> 基本操作</a></li>
<li><a href="#%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0" id="toc-通用函数"><span class="toc-section-number">1.5</span> 通用函数</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%88%87%E7%89%87%E5%92%8C%E8%BF%AD%E4%BB%A3" id="toc-索引切片和迭代"><span class="toc-section-number">1.6</span> 索引、切片和迭代</a></li>
</ul></li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%BD%A2%E7%8A%B6%E6%93%8D%E4%BD%9C" id="toc-数组形状操作"><span class="toc-section-number">2</span> 数组形状操作</a>
<ul>
<li><a href="#%E6%94%B9%E5%8F%98%E6%95%B0%E7%BB%84%E7%9A%84%E5%BD%A2%E7%8A%B6" id="toc-改变数组的形状"><span class="toc-section-number">2.1</span> 改变数组的形状</a></li>
<li><a href="#%E5%A0%86%E5%8F%A0%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84" id="toc-堆叠合并数组"><span class="toc-section-number">2.2</span> 堆叠合并数组</a></li>
<li><a href="#%E6%8B%86%E5%88%86%E6%95%B0%E7%BB%84" id="toc-拆分数组"><span class="toc-section-number">2.3</span> 拆分数组</a></li>
</ul></li>
<li><a href="#%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%A7%86%E5%9B%BE" id="toc-拷贝和视图"><span class="toc-section-number">3</span> 拷贝和视图</a>
<ul>
<li><a href="#%E6%97%A0%E6%8B%B7%E8%B4%9D" id="toc-无拷贝"><span class="toc-section-number">3.1</span> 无拷贝</a></li>
<li><a href="#%E8%A7%86%E5%9B%BE%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D" id="toc-视图和浅拷贝"><span class="toc-section-number">3.2</span> 视图和浅拷贝</a></li>
<li><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D" id="toc-深拷贝"><span class="toc-section-number">3.3</span> 深拷贝</a></li>
</ul></li>
<li><a href="#%E9%AB%98%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A2%E5%BC%95%E6%8A%80%E5%B7%A7" id="toc-高级索引和索引技巧"><span class="toc-section-number">4</span> 高级索引和索引技巧</a>
<ul>
<li><a href="#%E7%94%A8%E7%B4%A2%E5%BC%95%E6%95%B0%E7%BB%84%E6%9D%A5%E7%B4%A2%E5%BC%95" id="toc-用索引数组来索引"><span class="toc-section-number">4.1</span> 用索引数组来索引</a></li>
</ul></li>
</ul>
</div>

<style type="text/css">
.columns {
  display: flex;
}
</style>
<p>本文继<a href="/2025/10/pandas">《10分钟入门pandas》</a>之后，又一篇快速入门 Python 模块的文章，来自 NumPy 的官网<a href="https://numpy.org/doc/stable/user/quickstart.html">NumPy quickstart</a>，也是要同步添加 R 代码实现。</p>
<ol style="list-style-type: decimal">
<li>介绍 NumPy 中的数组操作，一维数组、二维数组和N维数组的差异。</li>
<li>使用常见函数操作数组（一些线性代数运算），不使用 for 循环，更 Python 范。</li>
<li>理解 NumPy 中 N 维数组的两个属性：轴 axis 和形状 shape。</li>
</ol>
<p>首先导入一个 Python 模块：</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>import numpy as np</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<p>R 内置一套数组操作的工具，<strong>abind</strong> 包提供额外的一些数组操作函数。</p>
<pre class="r"><code>library(abind) # abind / asub</code></pre>
</div>
</div>
<div id="基础" class="section level2" number="1">
<h2><span class="header-section-number">1</span> 基础</h2>
<p>NumPy 中主要的数据对象是多维数组，且数组中的元素类型都是相同的。数组的维数称之为轴 axes 。</p>
<p>比如，三维空间中的一个点的坐标 <code>[1, 2, 1]</code> 可以用数组来表示，它有一个轴，轴上有三个元素，它的长度为 3。下面这个数组有两个轴，第一个轴长度为 2，第二个轴长度为 3 。</p>
<pre class="python"><code>[[1., 0., 0.],
 [0., 1., 2.]]</code></pre>
<p>NumPy 中的数组用 <code>ndarray</code> 或 <code>array</code> 来表示。注意，<code>numpy.array</code> 和标准 Python 库中的类 <code>array.array</code> 是不同的，后者仅能处理一维数组的情况，功能更少。一个 <code>ndarray</code> 对象有如下一些重要的属性。</p>
<ol style="list-style-type: decimal">
<li><p><code>ndarray.ndim</code>
数组的维数（轴的数目）。</p></li>
<li><p><code>ndarray.shape</code>
数组的大小。用一个元组来表示数组中各个轴/维的大小。对一个 n 行 m 列的矩阵来说，它的形状 shape 是 (n,m) 。这个形状元组的长度是轴的数目，维数。</p></li>
<li><p><code>ndarray.size</code>
数组中所有元素的总数。它是形状元组中元素的连乘积。</p></li>
<li><p><code>ndarray.dtype</code>
数组中元素的数据类型。数组中元素的类型可以用标准 Python 类型来指定，NumPy 也提供它自己的类型，如 <code>numpy.int32</code>, <code>numpy.int16</code> 和 <code>numpy.float64</code>。</p></li>
<li><p><code>ndarray.itemsize</code>
数组中每个元素的存储大小（以字节 bytes 计）。如，数组中 float64 类型的元素，它的 itemsize 是 8 (=64/8) 个字节，而 complex32 类型有 4 (=32/8) 个字节。<code>ndarray.itemsize</code> 等价于 <code>ndarray.dtype.itemsize</code> 。</p></li>
<li><p><code>ndarray.data</code>
数组中的实际元素。通常，我们不需要使用这个属性，而是使用索引来连接数组中的元素。</p></li>
</ol>
<div id="一个例子" class="section level3" number="1.1">
<h3><span class="header-section-number">1.1</span> 一个例子</h3>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>import numpy as np
a = np.arange(15).reshape(3, 5)
a</code></pre>
<pre><code>## array([[ 0,  1,  2,  3,  4],
##        [ 5,  6,  7,  8,  9],
##        [10, 11, 12, 13, 14]])</code></pre>
<pre class="python"><code>a.shape</code></pre>
<pre><code>## (3, 5)</code></pre>
<pre class="python"><code>a.ndim</code></pre>
<pre><code>## 2</code></pre>
<pre class="python"><code>a.dtype.name</code></pre>
<pre><code>## &#39;int64&#39;</code></pre>
<pre class="python"><code>a.itemsize</code></pre>
<pre><code>## 8</code></pre>
<pre class="python"><code>a.size</code></pre>
<pre><code>## 15</code></pre>
<pre class="python"><code>type(a)</code></pre>
<pre><code>## &lt;class &#39;numpy.ndarray&#39;&gt;</code></pre>
<pre class="python"><code>b = np.array([6, 7, 8])
b</code></pre>
<pre><code>## array([6, 7, 8])</code></pre>
<pre class="python"><code>type(b)</code></pre>
<pre><code>## &lt;class &#39;numpy.ndarray&#39;&gt;</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<p>在 R 语言中，二维数组和矩阵是等价的。</p>
<pre class="r"><code>array(data = 0:14, dim = c(3, 5)) # 默认按列填充</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]    0    3    6    9   12
## [2,]    1    4    7   10   13
## [3,]    2    5    8   11   14</code></pre>
<pre class="r"><code>a = matrix(data = 0L:14L, nrow = 3, ncol = 5, byrow = T)
a</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]    0    1    2    3    4
## [2,]    5    6    7    8    9
## [3,]   10   11   12   13   14</code></pre>
<pre class="r"><code>dim(a)</code></pre>
<pre><code>## [1] 3 5</code></pre>
<pre class="r"><code>length(dim(a))</code></pre>
<pre><code>## [1] 2</code></pre>
<pre class="r"><code>typeof(a)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>length(a)</code></pre>
<pre><code>## [1] 15</code></pre>
<pre class="r"><code>class(a)</code></pre>
<pre><code>## [1] &quot;matrix&quot; &quot;array&quot;</code></pre>
<pre class="r"><code>mode(a)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>storage.mode(a)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>object.size(a)</code></pre>
<pre><code>## 280 bytes</code></pre>
</div>
</div>
</div>
<div id="创建数组" class="section level3" number="1.2">
<h3><span class="header-section-number">1.2</span> 创建数组</h3>
<p>创建不同元素类型的数组，比如整型数组、浮点型数组。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>import numpy as np
a = np.array([2, 3, 4])
a</code></pre>
<pre><code>## array([2, 3, 4])</code></pre>
<pre class="python"><code>a.dtype</code></pre>
<pre><code>## dtype(&#39;int64&#39;)</code></pre>
<pre class="python"><code>b = np.array([1.2, 3.5, 5.1])
b.dtype</code></pre>
<pre><code>## dtype(&#39;float64&#39;)</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>a = array(data = c(2L, 3L, 4L), dim = c(1, 3))
a</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    2    3    4</code></pre>
<pre class="r"><code>typeof(a)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>b = array(data = c(1.2, 3.5, 5.1), dim = c(1, 3))
typeof(b)</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
</div>
</div>
<p>创建一个二维数组，数组的元素类型可以在创建数组时指定。</p>
<pre class="python"><code>b = np.array([(1.5, 2, 3), (4, 5, 6)])
b</code></pre>
<pre><code>## array([[1.5, 2. , 3. ],
##        [4. , 5. , 6. ]])</code></pre>
<pre class="python"><code>c = np.array([(1, 2), (3, 4)], dtype=complex)
c</code></pre>
<pre><code>## array([[1.+0.j, 2.+0.j],
##        [3.+0.j, 4.+0.j]])</code></pre>
<p>当知道数组的大小，但是数组的内容暂定，需要初始化数组时，有三个函数可用，分别是 <code>zeros</code> 、<code>ones</code> 、<code>empty</code> 。</p>
<p>NumPy 的 <code>arange</code> 函数可以创建一个数值列（一维数组），返回类型也是数组，类似 Python 内置的函数 <code>range</code> 。但是，当传递浮点数参数时，由于有限的浮点数精度，<code>arange</code> 函数返回的元素个数难以预测。此时，最好使用函数 <code>linspace</code> ，它可以指定元素的个数（一维数组的长度）。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code># 初始化二维、多维数组
np.zeros((3, 4))</code></pre>
<pre><code>## array([[0., 0., 0., 0.],
##        [0., 0., 0., 0.],
##        [0., 0., 0., 0.]])</code></pre>
<pre class="python"><code>np.ones((2, 3, 4), dtype=np.int16)</code></pre>
<pre><code>## array([[[1, 1, 1, 1],
##         [1, 1, 1, 1],
##         [1, 1, 1, 1]],
## 
##        [[1, 1, 1, 1],
##         [1, 1, 1, 1],
##         [1, 1, 1, 1]]], dtype=int16)</code></pre>
<pre class="python"><code>np.empty((2, 3)) # 数组元素是随机的，不推荐</code></pre>
<pre><code>## array([[1.5, 2. , 3. ],
##        [4. , 5. , 6. ]])</code></pre>
<pre class="python"><code># 初始化一维数组 指定首尾和间距
np.arange(10, 30, 5)</code></pre>
<pre><code>## array([10, 15, 20, 25])</code></pre>
<pre class="python"><code>range(10, 30, 5)</code></pre>
<pre><code>## range(10, 30, 5)</code></pre>
<pre class="python"><code>np.arange(0, 2, 0.3)  # it accepts float arguments</code></pre>
<pre><code>## array([0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8])</code></pre>
<pre class="python"><code># 初始化一维数组 指定首尾和长度
from numpy import pi
np.linspace(0, 2, 9)                   # 9 numbers from 0 to 2</code></pre>
<pre><code>## array([0.  , 0.25, 0.5 , 0.75, 1.  , 1.25, 1.5 , 1.75, 2.  ])</code></pre>
<pre class="python"><code>x = np.linspace(0, 2 * pi, 100)        # useful to evaluate function at lots of points
f = np.sin(x)</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>array(data = 0, dim = c(3, 4))</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    0    0    0    0
## [2,]    0    0    0    0
## [3,]    0    0    0    0</code></pre>
<pre class="r"><code>array(data = 1, dim = c(3, 4, 2))</code></pre>
<pre><code>## , , 1
## 
##      [,1] [,2] [,3] [,4]
## [1,]    1    1    1    1
## [2,]    1    1    1    1
## [3,]    1    1    1    1
## 
## , , 2
## 
##      [,1] [,2] [,3] [,4]
## [1,]    1    1    1    1
## [2,]    1    1    1    1
## [3,]    1    1    1    1</code></pre>
<pre class="r"><code># 参数 by 指定间距
seq(from = 10, to = 30, by = 5)</code></pre>
<pre><code>## [1] 10 15 20 25 30</code></pre>
<pre class="r"><code>seq(from = 0, to = 2, by = 0.3)</code></pre>
<pre><code>## [1] 0.0 0.3 0.6 0.9 1.2 1.5 1.8</code></pre>
<pre class="r"><code># 参数 length.out 指定长度
seq(from = 0, to = 2, length.out = 9)</code></pre>
<pre><code>## [1] 0.00 0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00</code></pre>
<pre class="r"><code># pi 是内置的常数
x = seq(from = 0, to = 2*pi, length.out = 100)
f = sin(x)</code></pre>
</div>
</div>
</div>
<div id="打印数组" class="section level3" number="1.3">
<h3><span class="header-section-number">1.3</span> 打印数组</h3>
<p>在Python 环境中，打印（显示） NumPy 创建的数组，一维数组是向量，二维数组是矩阵，三维数组是矩阵列表。</p>
<pre class="python"><code>a = np.arange(6)                    # 1d array
print(a)</code></pre>
<pre><code>## [0 1 2 3 4 5]</code></pre>
<pre class="python"><code>b = np.arange(12).reshape(4, 3)     # 2d array
print(b)</code></pre>
<pre><code>## [[ 0  1  2]
##  [ 3  4  5]
##  [ 6  7  8]
##  [ 9 10 11]]</code></pre>
<pre class="python"><code>c = np.arange(24).reshape(2, 3, 4)  # 3d array
print(c)</code></pre>
<pre><code>## [[[ 0  1  2  3]
##   [ 4  5  6  7]
##   [ 8  9 10 11]]
## 
##  [[12 13 14 15]
##   [16 17 18 19]
##   [20 21 22 23]]]</code></pre>
<p>如果数组规模非常大，NumPy 会自动跳过数组的中间部分，只打印四周角落。</p>
<pre class="python"><code>print(np.arange(10000))</code></pre>
<pre><code>## [   0    1    2 ... 9997 9998 9999]</code></pre>
<pre class="python"><code>print(np.arange(10000).reshape(100, 100))</code></pre>
<pre><code>## [[   0    1    2 ...   97   98   99]
##  [ 100  101  102 ...  197  198  199]
##  [ 200  201  202 ...  297  298  299]
##  ...
##  [9700 9701 9702 ... 9797 9798 9799]
##  [9800 9801 9802 ... 9897 9898 9899]
##  [9900 9901 9902 ... 9997 9998 9999]]</code></pre>
</div>
<div id="基本操作" class="section level3" number="1.4">
<h3><span class="header-section-number">1.4</span> 基本操作</h3>
<p>两个数组之间的算术操作是数组中的元素逐对进行的。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>a = np.array([20, 30, 40, 50])
b = np.arange(4)
b</code></pre>
<pre><code>## array([0, 1, 2, 3])</code></pre>
<pre class="python"><code>c = a - b
c</code></pre>
<pre><code>## array([20, 29, 38, 47])</code></pre>
<pre class="python"><code>b**2</code></pre>
<pre><code>## array([0, 1, 4, 9])</code></pre>
<pre class="python"><code>10 * np.sin(a)</code></pre>
<pre><code>## array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])</code></pre>
<pre class="python"><code>a &lt; 35</code></pre>
<pre><code>## array([ True,  True, False, False])</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>a = array(data = c(20, 30, 40, 50), dim = c(1, 4))
b = array(data = 0:3, dim = c(1, 4))
b</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    0    1    2    3</code></pre>
<pre class="r"><code>c = a -b 
c</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]   20   29   38   47</code></pre>
<pre class="r"><code>b**2</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    0    1    4    9</code></pre>
<pre class="r"><code>10 * sin(a)</code></pre>
<pre><code>##       [,1]  [,2]  [,3]   [,4]
## [1,] 9.129 -9.88 7.451 -2.624</code></pre>
<pre class="r"><code>a &lt; 35</code></pre>
<pre><code>##      [,1] [,2]  [,3]  [,4]
## [1,] TRUE TRUE FALSE FALSE</code></pre>
</div>
</div>
<p>二维数组即矩阵，乘积算子 <code>*</code> 是对数组中的元素逐对进行的。而真正的矩阵乘法是用 <code>@</code> 或者函数 <code>dot</code> 。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>A = np.array([[1, 1],
              [0, 1]])
B = np.array([[2, 0],
              [3, 4]])
A * B     # elementwise product</code></pre>
<pre><code>## array([[2, 0],
##        [0, 4]])</code></pre>
<pre class="python"><code>A @ B     # matrix product</code></pre>
<pre><code>## array([[5, 4],
##        [3, 4]])</code></pre>
<pre class="python"><code>A.dot(B)  # another matrix product</code></pre>
<pre><code>## array([[5, 4],
##        [3, 4]])</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>A &lt;- array(data = c(1, 0, 1, 1), dim = c(2, 2))
B &lt;- array(data = c(2, 3, 0, 4), dim = c(2, 2))
A * B</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    2    0
## [2,]    0    4</code></pre>
<pre class="r"><code>A %*% B</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    5    4
## [2,]    3    4</code></pre>
<pre class="r"><code>crossprod(t(A), B)</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    5    4
## [2,]    3    4</code></pre>
</div>
</div>
<p>算子 <code>*=</code> 和 <code>+=</code> 修改现有的数组，而不是创建一个新的数组。</p>
<pre class="python"><code>rg = np.random.default_rng(1)  # create instance of default random number generator
a = np.ones((2, 3), dtype=int)
b = rg.random((2, 3))
a *= 3
a</code></pre>
<pre><code>## array([[3, 3, 3],
##        [3, 3, 3]])</code></pre>
<pre class="python"><code>b += a
b</code></pre>
<pre><code>## array([[3.51182162, 3.9504637 , 3.14415961],
##        [3.94864945, 3.31183145, 3.42332645]])</code></pre>
<pre class="python"><code># a += b  # b is not automatically converted to integer type</code></pre>
<p>当不同类型的数组进行算术操作，会涉及类型转化，通常是向上类型转化，如整型遇到浮点型，整型转化为浮点型。实数遇到复数，先将实数转化为复数。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>a = np.ones(3, dtype=np.int32)
b = np.linspace(0, pi, 3)
b.dtype.name</code></pre>
<pre><code>## &#39;float64&#39;</code></pre>
<pre class="python"><code>c = a + b
c</code></pre>
<pre><code>## array([1.        , 2.57079633, 4.14159265])</code></pre>
<pre class="python"><code>c.dtype.name</code></pre>
<pre><code>## &#39;float64&#39;</code></pre>
<pre class="python"><code>d = np.exp(c * 1j)
d</code></pre>
<pre><code>## array([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,
##        -0.54030231-0.84147098j])</code></pre>
<pre class="python"><code>d.dtype.name</code></pre>
<pre><code>## &#39;complex128&#39;</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>a = array(data = 1L, dim = c(1, 3))
b = seq(from = 0, to = pi, length.out = 3)
typeof(a)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>typeof(b)</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
<pre class="r"><code>c = a + b
c</code></pre>
<pre><code>##      [,1]  [,2]  [,3]
## [1,]    1 2.571 4.142</code></pre>
<pre class="r"><code>typeof(c)</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
<pre class="r"><code>d = exp(c * 1i)
d</code></pre>
<pre><code>##                [,1]            [,2]            [,3]
## [1,] 0.5403+0.8415i -0.8415+0.5403i -0.5403-0.8415i</code></pre>
<pre class="r"><code>typeof(d)</code></pre>
<pre><code>## [1] &quot;complex&quot;</code></pre>
</div>
</div>
<p>很多一元算子，如对数组元素求和、求最大值、求最小值，<code>ndarray</code> 类型提供内置的计算方法。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>a = rg.random((2, 3))
a</code></pre>
<pre><code>## array([[0.82770259, 0.40919914, 0.54959369],
##        [0.02755911, 0.75351311, 0.53814331]])</code></pre>
<pre class="python"><code>a.sum()</code></pre>
<pre><code>## np.float64(3.1057109529998157)</code></pre>
<pre class="python"><code>a.min()</code></pre>
<pre><code>## np.float64(0.027559113243068367)</code></pre>
<pre class="python"><code>a.max()</code></pre>
<pre><code>## np.float64(0.8277025938204418)</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>a = array(data = rnorm(6, 0, 1), dim = c(2, 3))
a</code></pre>
<pre><code>##         [,1]   [,2]   [,3]
## [1,]  0.3887 0.4374 -1.732
## [2,] -0.5898 0.5872 -1.054</code></pre>
<pre class="r"><code>sum(a)</code></pre>
<pre><code>## [1] -1.962</code></pre>
<pre class="r"><code>min(a)</code></pre>
<pre><code>## [1] -1.732</code></pre>
<pre class="r"><code>max(a)</code></pre>
<pre><code>## [1] 0.5872</code></pre>
</div>
</div>
<p>还有一些算子是根据数组的轴（行、列）计算的。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>b = np.arange(12).reshape(3, 4)
b</code></pre>
<pre><code>## array([[ 0,  1,  2,  3],
##        [ 4,  5,  6,  7],
##        [ 8,  9, 10, 11]])</code></pre>
<pre class="python"><code>b.sum(axis=0)     # sum of each column</code></pre>
<pre><code>## array([12, 15, 18, 21])</code></pre>
<pre class="python"><code>b.min(axis=1)     # min of each row</code></pre>
<pre><code>## array([0, 4, 8])</code></pre>
<pre class="python"><code>b.cumsum(axis=1)  # cumulative sum along each row</code></pre>
<pre><code>## array([[ 0,  1,  3,  6],
##        [ 4,  9, 15, 22],
##        [ 8, 17, 27, 38]])</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>b = matrix(data = 0:11, nrow = 3, ncol = 4, byrow = T)
b</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    0    1    2    3
## [2,]    4    5    6    7
## [3,]    8    9   10   11</code></pre>
<pre class="r"><code>colSums(b)</code></pre>
<pre><code>## [1] 12 15 18 21</code></pre>
<pre class="r"><code>apply(b, 2, sum)</code></pre>
<pre><code>## [1] 12 15 18 21</code></pre>
<pre class="r"><code>apply(b, 1, min)</code></pre>
<pre><code>## [1] 0 4 8</code></pre>
<pre class="r"><code>t(apply(b, 1, cumsum))</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    0    1    3    6
## [2,]    4    9   15   22
## [3,]    8   17   27   38</code></pre>
</div>
</div>
</div>
<div id="通用函数" class="section level3" number="1.5">
<h3><span class="header-section-number">1.5</span> 通用函数</h3>
<p>NumPy 提供一些常见的数学函数，如 <code>sin</code>、 <code>cos</code> 和 <code>exp</code>
等，这些函数称之为通用函数 Universal functions 。在 NumPy 中，在数组上应用正弦函数、指数函数、开平方根函数等是对数组的元素逐个运算。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>B = np.arange(3)
B</code></pre>
<pre><code>## array([0, 1, 2])</code></pre>
<pre class="python"><code>np.exp(B)</code></pre>
<pre><code>## array([1.        , 2.71828183, 7.3890561 ])</code></pre>
<pre class="python"><code>np.sqrt(B)</code></pre>
<pre><code>## array([0.        , 1.        , 1.41421356])</code></pre>
<pre class="python"><code>C = np.array([2., -1., 4.])
np.add(B, C)</code></pre>
<pre><code>## array([2., 0., 6.])</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>B = array(data = 0:2, dim = c(1, 3))
B</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    0    1    2</code></pre>
<pre class="r"><code>exp(B)</code></pre>
<pre><code>##      [,1]  [,2]  [,3]
## [1,]    1 2.718 7.389</code></pre>
<pre class="r"><code>sqrt(B)</code></pre>
<pre><code>##      [,1] [,2]  [,3]
## [1,]    0    1 1.414</code></pre>
<pre class="r"><code>C = array(data = c(2., -1., 4.), dim = c(1, 3))
B + C</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    2    0    6</code></pre>
</div>
</div>
</div>
<div id="索引切片和迭代" class="section level3" number="1.6">
<h3><span class="header-section-number">1.6</span> 索引、切片和迭代</h3>
<p>可以通过索引、切片和迭代的方式访问<strong>一维数组</strong>中的元素。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>a = np.arange(10)**3
a</code></pre>
<pre><code>## array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])</code></pre>
<pre class="python"><code>a[2]</code></pre>
<pre><code>## np.int64(8)</code></pre>
<pre class="python"><code>a[2:5]</code></pre>
<pre><code>## array([ 8, 27, 64])</code></pre>
<pre class="python"><code># equivalent to a[0:6:2] = 1000;
# from start to position 6, exclusive, set every 2nd element to 1000
a[:6:2] = 1000
a</code></pre>
<pre><code>## array([1000,    1, 1000,   27, 1000,  125,  216,  343,  512,  729])</code></pre>
<pre class="python"><code>a[::-1]  # reversed a</code></pre>
<pre><code>## array([ 729,  512,  343,  216,  125, 1000,   27, 1000,    1, 1000])</code></pre>
<pre class="python"><code>for i in a:
    print(i**(1 / 3.))</code></pre>
<pre><code>## 9.999999999999998
## 1.0
## 9.999999999999998
## 3.0
## 9.999999999999998
## 4.999999999999999
## 5.999999999999999
## 6.999999999999999
## 7.999999999999999
## 8.999999999999998</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>a = array(data = 0:9, dim = c(1, 10)) ** 3
a</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## [1,]    0    1    8   27   64  125  216  343  512   729</code></pre>
<pre class="r"><code>a[3]</code></pre>
<pre><code>## [1] 8</code></pre>
<pre class="r"><code>a[3:5]</code></pre>
<pre><code>## [1]  8 27 64</code></pre>
<pre class="r"><code>a[,c(1, 3, 5)] = 1000
a</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## [1,] 1000    1 1000   27 1000  125  216  343  512   729</code></pre>
<pre class="r"><code>rev(a)</code></pre>
<pre><code>##  [1]  729  512  343  216  125 1000   27 1000    1 1000</code></pre>
<pre class="r"><code>for (i in a)
    print(i**(1 / 3.))</code></pre>
<pre><code>## [1] 10
## [1] 1
## [1] 10
## [1] 3
## [1] 10
## [1] 5
## [1] 6
## [1] 7
## [1] 8
## [1] 9</code></pre>
</div>
</div>
<p>对于<strong>多维数组</strong>，每个轴可以有一个索引，索引以逗号分隔的元组表示。当提供的索引比轴的数目更少，缺失的索引将看作切片。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>def f(x, y):
    return 10 * x + y
b = np.fromfunction(f, (5, 4), dtype=int)
b</code></pre>
<pre><code>## array([[ 0,  1,  2,  3],
##        [10, 11, 12, 13],
##        [20, 21, 22, 23],
##        [30, 31, 32, 33],
##        [40, 41, 42, 43]])</code></pre>
<pre class="python"><code>b[2, 3]</code></pre>
<pre><code>## np.int64(23)</code></pre>
<pre class="python"><code>b[0:5, 1]  # each row in the second column of b</code></pre>
<pre><code>## array([ 1, 11, 21, 31, 41])</code></pre>
<pre class="python"><code>b[:, 1]    # equivalent to the previous example</code></pre>
<pre><code>## array([ 1, 11, 21, 31, 41])</code></pre>
<pre class="python"><code>b[1:3, :]  # each column in the second and third row of b</code></pre>
<pre><code>## array([[10, 11, 12, 13],
##        [20, 21, 22, 23]])</code></pre>
<pre class="python"><code>b[-1]   # the last row. Equivalent to b[-1, :]</code></pre>
<pre><code>## array([40, 41, 42, 43])</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>a = array(data = 1, dim = c(5, 4))
b = array(data = rep(0:3, each = 5), dim = c(5, 4))
b = 10 * 0:4 + b
b</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    0    1    2    3
## [2,]   10   11   12   13
## [3,]   20   21   22   23
## [4,]   30   31   32   33
## [5,]   40   41   42   43</code></pre>
<pre class="r"><code>b[3, 4]</code></pre>
<pre><code>## [1] 23</code></pre>
<pre class="r"><code>b[1:5, 2]</code></pre>
<pre><code>## [1]  1 11 21 31 41</code></pre>
<pre class="r"><code>b[, 2]</code></pre>
<pre><code>## [1]  1 11 21 31 41</code></pre>
<pre class="r"><code>b[2:3, ]</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]   10   11   12   13
## [2,]   20   21   22   23</code></pre>
<pre class="r"><code>b[-1, ] # 它表示去掉第一行，这与 Python 差别很大</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]   10   11   12   13
## [2,]   20   21   22   23
## [3,]   30   31   32   33
## [4,]   40   41   42   43</code></pre>
</div>
</div>
<p>访问多维数组：切片。下面是一个 2x2x3 的三维数组，访问数组中的切片时，以省略号 <code>...</code>
表示未明写的维度。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>c = np.array([[[  0,  1,  2],  # a 3D array (two stacked 2D arrays)
               [ 10, 12, 13]],
              [[100, 101, 102],
               [110, 112, 113]]])
c</code></pre>
<pre><code>## array([[[  0,   1,   2],
##         [ 10,  12,  13]],
## 
##        [[100, 101, 102],
##         [110, 112, 113]]])</code></pre>
<pre class="python"><code>c.shape</code></pre>
<pre><code>## (2, 2, 3)</code></pre>
<pre class="python"><code>c[1, ...]  # same as c[1, :, :] or c[1]</code></pre>
<pre><code>## array([[100, 101, 102],
##        [110, 112, 113]])</code></pre>
<pre class="python"><code>c[..., 2]  # same as c[:, :, 2]</code></pre>
<pre><code>## array([[  2,  13],
##        [102, 113]])</code></pre>
<p>注意：缺省维度的表示与 R 语言是不一样的。</p>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>c = array(data = c(0 , 10, 1, 12, 2, 13,
                   100, 110, 101, 112,
                   102, 113), dim = c(2, 3, 2))
c</code></pre>
<pre><code>## , , 1
## 
##      [,1] [,2] [,3]
## [1,]    0    1    2
## [2,]   10   12   13
## 
## , , 2
## 
##      [,1] [,2] [,3]
## [1,]  100  101  102
## [2,]  110  112  113</code></pre>
<pre class="r"><code>dim(c)</code></pre>
<pre><code>## [1] 2 3 2</code></pre>
<pre class="r"><code>c[, ,2]</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]  100  101  102
## [2,]  110  112  113</code></pre>
<pre class="r"><code>c[, 3,]</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    2  102
## [2,]   13  113</code></pre>
</div>
</div>
<p>多维数组的<strong>迭代操作</strong>是基于第一个轴（行）。</p>
<pre class="python"><code>for row in c:
    print(row)</code></pre>
<pre><code>## [[ 0  1  2]
##  [10 12 13]]
## [[100 101 102]
##  [110 112 113]]</code></pre>
<p>如果是遍历数组中的每一个元素，则需要用 <code>flat</code> 将数组转成向量。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>for element in c.flat:
    print(element)</code></pre>
<pre><code>## 0
## 1
## 2
## 10
## 12
## 13
## 100
## 101
## 102
## 110
## 112
## 113</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<p>R 语言中迭代多维数组与 Python 不同。</p>
<pre class="r"><code>for (row in c) {
  print(row)
}</code></pre>
<pre><code>## [1] 0
## [1] 10
## [1] 1
## [1] 12
## [1] 2
## [1] 13
## [1] 100
## [1] 110
## [1] 101
## [1] 112
## [1] 102
## [1] 113</code></pre>
</div>
</div>
</div>
</div>
<div id="数组形状操作" class="section level2" number="2">
<h2><span class="header-section-number">2</span> 数组形状操作</h2>
<div id="改变数组的形状" class="section level3" number="2.1">
<h3><span class="header-section-number">2.1</span> 改变数组的形状</h3>
<p>将 3x4 的数组转为 6x2 的数组。数组中的元素是按行填充/排列的，操作数组时，也是按行进行的。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>a = np.floor(10 * rg.random((3, 4)))
a</code></pre>
<pre><code>## array([[3., 7., 3., 4.],
##        [1., 4., 2., 2.],
##        [7., 2., 4., 9.]])</code></pre>
<pre class="python"><code>a.shape</code></pre>
<pre><code>## (3, 4)</code></pre>
<pre class="python"><code>a.ravel()  # returns the array, flattened</code></pre>
<pre><code>## array([3., 7., 3., 4., 1., 4., 2., 2., 7., 2., 4., 9.])</code></pre>
<pre class="python"><code>a.reshape(6, 2)  # returns the array with a modified shape</code></pre>
<pre><code>## array([[3., 7.],
##        [3., 4.],
##        [1., 4.],
##        [2., 2.],
##        [7., 2.],
##        [4., 9.]])</code></pre>
<pre class="python"><code>a.T  # returns the array, transposed</code></pre>
<pre><code>## array([[3., 1., 7.],
##        [7., 4., 2.],
##        [3., 2., 4.],
##        [4., 2., 9.]])</code></pre>
<pre class="python"><code>a.T.shape</code></pre>
<pre><code>## (4, 3)</code></pre>
<pre class="python"><code>a.shape</code></pre>
<pre><code>## (3, 4)</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<p>R 语言中，对数组的操作默认都是按列进行的。</p>
<pre class="r"><code>a = floor(10 * array(data = runif(12), dim = c(3, 4)))
a</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    8    7    1    6
## [2,]    8    9    3    1
## [3,]    8    1    2    7</code></pre>
<pre class="r"><code>dim(a)</code></pre>
<pre><code>## [1] 3 4</code></pre>
<pre class="r"><code>as.vector(a)</code></pre>
<pre><code>##  [1] 8 8 8 7 9 1 1 3 2 6 1 7</code></pre>
<pre class="r"><code>array(as.vector(a), dim = c(6, 2))</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    8    1
## [2,]    8    3
## [3,]    8    2
## [4,]    7    6
## [5,]    9    1
## [6,]    1    7</code></pre>
<pre class="r"><code>aperm(a, perm = c(2, 1))</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    8    8    8
## [2,]    7    9    1
## [3,]    1    3    2
## [4,]    6    1    7</code></pre>
<pre class="r"><code>dim(aperm(a))</code></pre>
<pre><code>## [1] 4 3</code></pre>
<pre class="r"><code>dim(a)</code></pre>
<pre><code>## [1] 3 4</code></pre>
<p>函数 <code>aperm()</code> 的参数 <code>perm</code> 接受一个整型向量，向量的长度是维数，向量的元素是 1:N （N 代表维数）之间的数。常见的三维数组中， 1 代表行，2 代表列，3 表示剩下的那个轴（维度）。</p>
</div>
</div>
<p>NumPy 中的 <code>resize</code> 函数可以直接修改原来的数组。如果函数 <code>reshape</code> 其中一个参数为 -1 ，它表示该位置根据计算得出。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>a</code></pre>
<pre><code>## array([[3., 7., 3., 4.],
##        [1., 4., 2., 2.],
##        [7., 2., 4., 9.]])</code></pre>
<pre class="python"><code>a.resize((2, 6))
a</code></pre>
<pre><code>## array([[3., 7., 3., 4., 1., 4.],
##        [2., 2., 7., 2., 4., 9.]])</code></pre>
<pre class="python"><code>a.reshape(3, -1)</code></pre>
<pre><code>## array([[3., 7., 3., 4.],
##        [1., 4., 2., 2.],
##        [7., 2., 4., 9.]])</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<p>R 语言中无此强行转化数组形状的操作。我暂时也没有想到应用场景。</p>
</div>
</div>
</div>
<div id="堆叠合并数组" class="section level3" number="2.2">
<h3><span class="header-section-number">2.2</span> 堆叠合并数组</h3>
<p>垂直 <code>vstack</code> 还是水平 <code>hstack</code> 方向堆叠数组。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>a = np.floor(10 * rg.random((2, 2)))
a</code></pre>
<pre><code>## array([[9., 7.],
##        [5., 2.]])</code></pre>
<pre class="python"><code>b = np.floor(10 * rg.random((2, 2)))
b</code></pre>
<pre><code>## array([[1., 9.],
##        [5., 1.]])</code></pre>
<pre class="python"><code>np.vstack((a, b))</code></pre>
<pre><code>## array([[9., 7.],
##        [5., 2.],
##        [1., 9.],
##        [5., 1.]])</code></pre>
<pre class="python"><code>np.hstack((a, b))</code></pre>
<pre><code>## array([[9., 7., 1., 9.],
##        [5., 2., 5., 1.]])</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>a = floor(10 * array(data = runif(4), dim = c(2, 2)))
a</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    1    3
## [2,]    1    3</code></pre>
<pre class="r"><code>b = floor(10 * array(data = runif(4), dim = c(2, 2)))
b</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    9    3
## [2,]    6    5</code></pre>
<pre class="r"><code>rbind(a, b)</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    1    3
## [2,]    1    3
## [3,]    9    3
## [4,]    6    5</code></pre>
<pre class="r"><code>cbind(a, b)</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    3    9    3
## [2,]    1    3    6    5</code></pre>
<pre class="r"><code>library(abind)
abind(a, b, along = 1) # rbind</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    1    3
## [2,]    1    3
## [3,]    9    3
## [4,]    6    5</code></pre>
<pre class="r"><code>abind(a, b, along = 2) # cbind</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    3    9    3
## [2,]    1    3    6    5</code></pre>
</div>
</div>
<p>函数 <code>column_stack</code> 可以将两个一维数组堆叠形成一个二维数组。对二维数组的堆叠操作来说，函数 <code>column_stack</code> 等价于函数 <code>hstack</code> 。</p>
<pre class="python"><code>from numpy import newaxis
np.column_stack((a, b))  # with 2D arrays</code></pre>
<pre><code>## array([[9., 7., 1., 9.],
##        [5., 2., 5., 1.]])</code></pre>
<pre class="python"><code>a = np.array([4., 2.])
b = np.array([3., 8.])
np.column_stack((a, b))  # returns a 2D array</code></pre>
<pre><code>## array([[4., 3.],
##        [2., 8.]])</code></pre>
<pre class="python"><code>np.hstack((a, b))        # the result is different</code></pre>
<pre><code>## array([4., 2., 3., 8.])</code></pre>
<pre class="python"><code>a[:, newaxis]  # view `a` as a 2D column vector</code></pre>
<pre><code>## array([[4.],
##        [2.]])</code></pre>
<pre class="python"><code>np.column_stack((a[:, newaxis], b[:, newaxis]))</code></pre>
<pre><code>## array([[4., 3.],
##        [2., 8.]])</code></pre>
<pre class="python"><code>np.hstack((a[:, newaxis], b[:, newaxis]))  # the result is the same</code></pre>
<pre><code>## array([[4., 3.],
##        [2., 8.]])</code></pre>
</div>
<div id="拆分数组" class="section level3" number="2.3">
<h3><span class="header-section-number">2.3</span> 拆分数组</h3>
<p>函数 <code>hsplit</code> 和 <code>vsplit</code> 可以分别将数组按照水平方向、垂直方向拆分，还可以指定分割点。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>a = np.floor(10 * rg.random((2, 12)))
a</code></pre>
<pre><code>## array([[6., 7., 6., 9., 0., 5., 4., 0., 6., 8., 5., 2.],
##        [8., 5., 5., 7., 1., 8., 6., 7., 1., 8., 1., 0.]])</code></pre>
<pre class="python"><code># Split `a` into 3
np.hsplit(a, 3)</code></pre>
<pre><code>## [array([[6., 7., 6., 9.],
##        [8., 5., 5., 7.]]), array([[0., 5., 4., 0.],
##        [1., 8., 6., 7.]]), array([[6., 8., 5., 2.],
##        [1., 8., 1., 0.]])]</code></pre>
<pre class="python"><code># Split `a` after the third and the fourth column
np.hsplit(a, (3, 4))</code></pre>
<pre><code>## [array([[6., 7., 6.],
##        [8., 5., 5.]]), array([[9.],
##        [7.]]), array([[0., 5., 4., 0., 6., 8., 5., 2.],
##        [1., 8., 6., 7., 1., 8., 1., 0.]])]</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>a = floor(10 * array(data = runif(24), dim = c(2, 12)))
a</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
## [1,]    6    9    1    2    0    1    4    4    4     5     5     3
## [2,]    2    0    6    1    6    1    1    6    6     8     5     6</code></pre>
<pre class="r"><code>asplit(a, MARGIN = 1)</code></pre>
<pre><code>## [[1]]
##  [1] 6 9 1 2 0 1 4 4 4 5 5 3
## 
## [[2]]
##  [1] 2 0 6 1 6 1 1 6 6 8 5 6</code></pre>
<p><code>asplit()</code> 函数只能按某一个边际维度拆分数据，并不支持 3 等分，按指定位置切分这样的操作。</p>
</div>
</div>
</div>
</div>
<div id="拷贝和视图" class="section level2" number="3">
<h2><span class="header-section-number">3</span> 拷贝和视图</h2>
<div id="无拷贝" class="section level3" number="3.1">
<h3><span class="header-section-number">3.1</span> 无拷贝</h3>
<pre class="python"><code>a = np.array([[ 0,  1,  2,  3],
              [ 4,  5,  6,  7],
              [ 8,  9, 10, 11]])
b = a            # no new object is created
b is a           # a and b are two names for the same ndarray object</code></pre>
<pre><code>## True</code></pre>
<pre class="python"><code>def f(x):
    print(id(x))
id(a)  # id is a unique identifier of an object </code></pre>
<pre><code>## 4508540272</code></pre>
<pre class="python"><code>f(a)   </code></pre>
<pre><code>## 4508540272</code></pre>
<p>注意： R 语言中都是深拷贝行为，先复制一份原数据，再修改数据，最后，保存在新的数据对象中。</p>
</div>
<div id="视图和浅拷贝" class="section level3" number="3.2">
<h3><span class="header-section-number">3.2</span> 视图和浅拷贝</h3>
<p>修改原来数组中的元素</p>
<pre class="python"><code>c = a.view()
c is a</code></pre>
<pre><code>## False</code></pre>
<pre class="python"><code>c.base is a            # c is a view of the data owned by a</code></pre>
<pre><code>## True</code></pre>
<pre class="python"><code>c.flags.owndata</code></pre>
<pre><code>## False</code></pre>
<pre class="python"><code>c = c.reshape((2, 6))  # a&#39;s shape doesn&#39;t change, reassigned c is still a view of a
a.shape</code></pre>
<pre><code>## (3, 4)</code></pre>
<pre class="python"><code>c[0, 4] = 1234         # a&#39;s data changes
a</code></pre>
<pre><code>## array([[   0,    1,    2,    3],
##        [1234,    5,    6,    7],
##        [   8,    9,   10,   11]])</code></pre>
<pre class="python"><code>s = a[:, 1:3]
s[:] = 10  # s[:] is a view of s. Note the difference between s = 10 and s[:] = 10
a</code></pre>
<pre><code>## array([[   0,   10,   10,    3],
##        [1234,   10,   10,    7],
##        [   8,   10,   10,   11]])</code></pre>
<p>对数组 c 的修改，同步发生到 a 身上。</p>
</div>
<div id="深拷贝" class="section level3" number="3.3">
<h3><span class="header-section-number">3.3</span> 深拷贝</h3>
<p>创建一个新的数组，在新的数组中操作</p>
<pre class="python"><code>d = a.copy()  # a new array object with new data is created
d is a</code></pre>
<pre><code>## False</code></pre>
<pre class="python"><code>d.base is a  # d doesn&#39;t share anything with a</code></pre>
<pre><code>## False</code></pre>
<pre class="python"><code>d[0, 0] = 9999
d</code></pre>
<pre><code>## array([[9999,   10,   10,    3],
##        [1234,   10,   10,    7],
##        [   8,   10,   10,   11]])</code></pre>
<pre class="python"><code>a</code></pre>
<pre><code>## array([[   0,   10,   10,    3],
##        [1234,   10,   10,    7],
##        [   8,   10,   10,   11]])</code></pre>
</div>
</div>
<div id="高级索引和索引技巧" class="section level2" number="4">
<h2><span class="header-section-number">4</span> 高级索引和索引技巧</h2>
<div id="用索引数组来索引" class="section level3" number="4.1">
<h3><span class="header-section-number">4.1</span> 用索引数组来索引</h3>
<p>一个数组的元素代表另一个数组元素的索引位置。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>a = np.arange(12)**2  # the first 12 square numbers
a</code></pre>
<pre><code>## array([  0,   1,   4,   9,  16,  25,  36,  49,  64,  81, 100, 121])</code></pre>
<pre class="python"><code>i = np.array([1, 1, 3, 8, 5])  # an array of indices
a[i]  # the elements of `a` at the positions `i`</code></pre>
<pre><code>## array([ 1,  1,  9, 64, 25])</code></pre>
<pre class="python"><code>j = np.array([[3, 4], [9, 7]])  # a bidimensional array of indices
a[j]  # the same shape as `j`</code></pre>
<pre><code>## array([[ 9, 16],
##        [81, 49]])</code></pre>
<pre class="python"><code>a = np.arange(12).reshape(3, 4)
a</code></pre>
<pre><code>## array([[ 0,  1,  2,  3],
##        [ 4,  5,  6,  7],
##        [ 8,  9, 10, 11]])</code></pre>
<pre class="python"><code>i = np.array([[0, 1],  # indices for the first dim of `a`
              [1, 2]])
j = np.array([[2, 1],  # indices for the second dim
              [3, 3]])
a[i, j]  # i and j must have equal shape</code></pre>
<pre><code>## array([[ 2,  5],
##        [ 7, 11]])</code></pre>
<pre class="python"><code>a[i, 2]</code></pre>
<pre><code>## array([[ 2,  6],
##        [ 6, 10]])</code></pre>
<pre class="python"><code>a[:, j]</code></pre>
<pre><code>## array([[[ 2,  1],
##         [ 3,  3]],
## 
##        [[ 6,  5],
##         [ 7,  7]],
## 
##        [[10,  9],
##         [11, 11]]])</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code># 一维数组
a = array(data = (0:11)^2, dim = c(1, 12)) 
a</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
## [1,]    0    1    4    9   16   25   36   49   64    81   100   121</code></pre>
<pre class="r"><code>i = array(data = c(2, 2, 4, 9, 6), dim = c(1, 5))
a[i]</code></pre>
<pre><code>## [1]  1  1  9 64 25</code></pre>
<pre class="r"><code>j = array(data = c(4, 10, 5, 8), dim = c(2, 2))
a[as.vector(j)]</code></pre>
<pre><code>## [1]  9 81 16 49</code></pre>
<pre class="r"><code>library(abind)
# 按列索引
asub(x = a, idx = list(c(4, 10, 5, 8)), dims = 2)</code></pre>
<pre><code>## [1]  9 81 16 49</code></pre>
<p>R 语言的索引规则与 Python 很不一样，在 R 语言中，按照边际 MARGIN 来切片或索引。</p>
</div>
</div>
</div>
</div>
