---
title: 贝叶斯数据分析工作流
author: 黄湘云
date: '2023-10-02'
slug: bayesian-workflow
categories:
  - 统计应用
tags:
  - 贝叶斯空间分析
  - 核辐射强度预测
  - 贝叶斯高斯过程
  - 极大似然估计
  - 广义最小二乘估计
  - 边际似然函数
output:
  blogdown::html_page:
    toc: true
    number_sections: true
link-citations: true
math: true
csl: institute-of-mathematical-statistics.csl
bibliography: 
  - refer.bib
description: "贝叶斯数据分析工作流。一文搞懂贝叶斯空间数据分析工作流"
---

```{r}
#| echo: false

knitr::opts_chunk$set(
  comment = "#>", collapse = TRUE, cache = TRUE
)
```

::: rmdtip
1.  贝叶斯高斯过程回归和贝叶斯泊松过程回归
2.  核辐射数据集的贝叶斯分析
3.  贝叶斯简单克里金插值及 Stan 实现
:::

# 本文概览

1.  本文概览：贝叶斯数据分析工作流的概览
2.  以预测朗格拉普岛核辐射强度分布为例，详细介绍贝叶斯工作流中的各个环节。
    1.  统计建模：模型结构、组成部分、参数解释
    2.  数据准备：观测数据、预测数据、参数初值
    3.  软件准备：软件环境
    4.  代码编写：已有函数及其解释
    5.  代码编译：编译选项及解释
    6.  模型采样：采样算法简介，NUTS 算法参数说明
    7.  模型输出：模型采样输出结果的说明和解释，
    8.  模型诊断：参数迭代轨迹和分布，诊断结果
    9.  代码优化：根据诊断结果优化，比如并行和向量化
    10. 模型评估：pDIC、WAIC、LOO-CV
    11. 模型比较：泊松对数、对数高斯建模比较
    12. 模型预测：克里金插值预测
3.  本文小结：
    1.  分析、建模经验
    2.  Stan 代码调优

# 工作流

本文主要参考《Bayesian Workflow》 [@Gelman2020]

## 统计建模

### 对数高斯模型

相邻位置的核辐射强度是相关的，离得近的比离得远的更相关。下面对辐射强度建模，假定随机效应之间存在相关性结构，去掉随机效应相互独立的假设，这更符合位置效应存在相互影响的实际情况。

$$
\log\big\{\lambda(x_i)\big\} = \beta + S(x_{i})
$$

其中，$\beta$ 表示截距，相当于平均水平，$\lambda(x_i)$ 表示位置 $x_i$ 处的辐射强度，$S(x_{i})$ 表示位置 $x_i$ 处的空间效应，$S(x),x \in \mathcal{D} \subset{\mathbb{R}^2}$ 是二维平稳空间高斯过程 $\mathcal{S}$ 的具体实现。 $\mathcal{D}$ 表示研究区域，可以理解为朗格拉普岛，它是二维实平面 $\mathbb{R}^2$ 的子集。

### 泊松对数模型

广义线性模型并没有考虑距离相关性，它认为各个观测点的数据是相互独立的。因此，在广义线性模型的基础上添加位置相关的随机效应，用以刻画未能直接观测到的潜在影响。

根据 ${}^{137}\mathrm{Cs}$ 放出伽马射线，在 $n=157$ 个采样点，分别以时间间隔 $t_i$ 测量辐射量 $y(x_i)$，建立泊松型空间广义线性混合效应模型[@Diggle1998]。

$$
\begin{aligned}
\log\{\lambda(x_i)\} & =  \beta + S(x_{i})\\
y(x_{i}) &\sim \mathrm{Poisson}\big(t_i\lambda(x_i)\big)
\end{aligned}
$$

其中，$\beta$ 表示截距，相当于平均水平，$\lambda(x_i)$ 表示位置 $x_i$ 处的辐射强度，$S(x_{i})$ 表示位置 $x_i$ 处的空间效应，$S(x),x \in \mathcal{D} \subset{\mathbb{R}^2}$ 是二维平稳空间高斯过程 $\mathcal{S}$ 的具体实现。 $\mathcal{D}$ 表示研究区域，可以理解为朗格拉普岛，它是二维实平面 $\mathbb{R}^2$ 的子集。

随机过程 $S(x)$ 的自协方差函数常用的有指数型、幂二次指数型（高斯型）和梅隆型，形式如下：

$$
\begin{aligned}
\mathsf{Cov}\{S(x_i), S(x_j)\} &= \sigma^2 \exp\big( -\frac{\|x_i -x_j\|_{2}}{\phi} \big) \\
\mathsf{Cov}\{ S(x_i), S(x_j) \} &= \sigma^2 \exp\big( -\frac{\|x_i -x_j\|_{2}^{2}}{2\phi^2} \big) \\
\mathsf{Cov}\{ S(x_i), S(x_j) \} &= \sigma^2 \frac{2^{1 - \nu}}{\Gamma(\nu)}
\left(\sqrt{2\nu}\frac{\|x_i -x_j\|_{2}}{\phi}\right)^{\nu}
K_{\nu}\left(\sqrt{2\nu}\frac{\|x_i -x_j\|_{2}}{\phi}\right) \\
K_{\nu}(x) &= \int_{0}^{\infty}\exp(-x \cosh t) \cosh (\nu t) \mathrm{dt}
\end{aligned}
$$

待估参数：代表方差的 $\sigma^2$ 和代表范围的 $\phi$ 。当 $\nu = 1/2$ 时，梅隆型退化为指数型。

## 数据准备

### 观测数据

```{r}
# 加载数据
rongelap <- readRDS(file = "data/rongelap.rds")
rongelap_coastline <- readRDS(file = "data/rongelap_coastline.rds")

# 对数高斯模型
rongelap_gaussian_d <- list(
  N = nrow(rongelap), # 观测记录的条数
  D = 2, # 2 维坐标
  X = rongelap[, c("cX", "cY")] / 6000, # N x 2 坐标矩阵
  y = log(rongelap$counts / rongelap$time) # N 向量
)
```

### 预测数据

```{r}
#| message: false

library(sf)
library(abind)
library(stars)

rongelap_sf <- st_as_sf(rongelap, coords = c("cX", "cY"), dim = "XY")
rongelap_coastline_sf <- st_as_sf(rongelap_coastline, coords = c("cX", "cY"), dim = "XY")
rongelap_coastline_sfp <- st_cast(st_combine(st_geometry(rongelap_coastline_sf)), "POLYGON")

rongelap_coastline_buffer <- st_buffer(rongelap_coastline_sfp, dist = 50)
# 构造带边界约束的网格
rongelap_coastline_grid <- st_make_grid(rongelap_coastline_buffer, n = c(150, 75))
# 将 sfc 类型转化为 sf 类型
rongelap_coastline_grid <- st_as_sf(rongelap_coastline_grid)
rongelap_coastline_buffer <- st_as_sf(rongelap_coastline_buffer)
rongelap_grid <- rongelap_coastline_grid[rongelap_coastline_buffer, op = st_intersects]
# 计算网格中心点坐标
rongelap_grid_centroid <- st_centroid(rongelap_grid)

# 1612 个点
rongelap_grid_df <- as.data.frame(st_coordinates(rongelap_grid_centroid))
colnames(rongelap_grid_df) <- c("cX", "cY")
```

`rongelap_grid_df` 即为需要预测核辐射强度的位置

### 初始数据

对数高斯模型

```{r}
set.seed(20232023)
nchains <- 2 # 2 条迭代链
# 给每条链设置不同的参数初始值
inits_data_gaussian <- lapply(1:nchains, function(i) {
  list(
    beta = rnorm(1),
    sigma = runif(1),
    phi = runif(1)
  )
})
```


## 软件准备

下载、编译 CmdStan 软件框架，配置环境变量

```{r}
Sys.setenv(CMDSTAN = "/opt/cmdstan/cmdstan-2.32.2")
Sys.setenv(CMDSTANR_NO_VER_CHECK = TRUE)
```

加载 **cmdstanr**、**bayesplot** 和 **loo** 等 R 包。

```{r}
#| message: false

library(cmdstanr)
library(ggplot2)
library(bayesplot)
library(loo)
library(projpred)
```

-   **cmdstanr** 配置 Stan 环境、编译 Stan 代码（设置编译参数）和采样（设置采样算法和参数）。
-   **bayesplot** [@Gabry2019] 可视化模型参数的后验分布，迭代轨迹的散点图、迭代链的自相关图、后验分布的直方图等。
-   **loo** 模型评估与比较，计算 LOO 和 WAIC 等指标。
-   **projpred** 变量选择
-   **posterior** 后验推断

## 代码编写

### 对数高斯模型

$$
\begin{aligned}
\beta &\sim \text{std_normal}(0,1) \\
\sigma &\sim \text{inv_gamma}(5,5) \\
\phi &\sim \text{half_std_normal}(0,1) \\
\bm{y} &\sim \text{multivariate_normal}(\bm{\beta}, \sigma^2 \Sigma+ \delta^2 I)
\end{aligned}
$$

其中，$\beta$ 代表截距，先验分布为标准正态分布，$\sigma$ 代表高斯过程的方差参数（信号），先验分布为逆伽马分布，$\phi$ 代表高斯过程的范围参数，先验分布为半标准正态分布，$y$ 代表响应变量的取值，给定参数和数据的条件分布为多元正态分布，$\Sigma$ 代表协方差矩阵，$I$ 代表与采样点数量相同的单位矩阵， $\delta$ 是非常小的常数（可以看作可忽略的噪声），使得协方差矩阵正定，确保 Cholesky 分解。

```{verbatim, file="code/rongelap_gaussian.stan", lang="stan"}
```

代码中，`gp_exponential_cov` 表示空间相关性结构选择了指数型，详见 Stan 函数手册中的[指数型核函数表示](https://mc-stan.org/docs/functions-reference/gaussian-process-covariance-functions.html#exponential-kernel)。`cholesky_decompose` 表示对协方差矩阵做 Cholesky 分解，分解出来的下三角矩阵作为多元正态分布的参数，详见 Stan 函数手册中的 [Cholesky 分解](https://mc-stan.org/docs/functions-reference/linear-algebra-functions-and-solvers.html#cholesky-decomposition)。 `multi_normal_cholesky` 表示基于 Cholesky 分解的多元正态分布。详见 Stan 函数手册中的多元正态分布的 [Cholesky](https://mc-stan.org/docs/functions-reference/multi-normal-cholesky-fun.html) 参数化表示。


## 代码编译

编译模型

```{r}
#| message: false

mod_rongelap_gaussian <- cmdstan_model(
  stan_file = "code/rongelap_gaussian.stan",
  compile = TRUE, cpp_options = list(stan_threads = TRUE)
)
```

## 模型采样

拟合模型

```{r}
#| message: false

# 对数高斯模型
fit_rongelap_gaussian <- mod_rongelap_gaussian$sample(
  data = rongelap_gaussian_d,   # 观测数据
  init = inits_data_gaussian,   # 迭代初值
  iter_warmup = 500,           # 每条链预处理迭代次数
  iter_sampling = 1000,         # 每条链总迭代次数
  chains = nchains,             # 马尔科夫链的数目
  parallel_chains = 2,      # 指定 CPU 核心数，可以给每条链分配一个
  threads_per_chain = 1,    # 每条链设置一个线程
  show_messages = FALSE,    # 不显示迭代的中间过程
  refresh = 0,              # 不显示采样的进度
  output_dir = "data/",
  seed = 20232023           # 设置随机数种子，不要使用 set.seed() 函数
)
```

跑模型的时间花费分别为 146.4s 和 216.9s

```{r}
# 诊断
fit_rongelap_gaussian$diagnostic_summary()
```

## 模型输出

模型参数的估计结果，输出结果保留 4 位有效数字。

```{r}
# 对数高斯模型
fit_rongelap_gaussian$summary(
  variables = c("lp__", "beta", "sigma", "phi"),
  .num_args = list(sigfig = 4, notation = "dec")
)
```

::: rmdtip
作为对比，提供频率派参数估计结果，采用 **nlme** 包拟合对数高斯模型。

```{r}
library(nlme)
fit_rongelap_nlme <- gls(log(counts / time) ~ 1,
  correlation = corExp(value = 200, form = ~ cX + cY, nugget = FALSE),
  data = rongelap, method = "REML"
)
fit_rongelap_nlme
```

结果显示 $\beta = 1.826, \phi = 110.8, \sigma^2 = 0.5632^2 = 0.3172$ 。
:::

## 模型诊断

### 对数高斯模型

```{r}
#| label: fig-rongelap-gaussian-trace
#| fig-cap: $\sigma$ 和 $\phi$ 的迭代轨迹

library(ggplot2)
library(bayesplot)
mcmc_trace(fit_rongelap_gaussian$draws(c("sigma", "phi")),
           facet_args = list(
             labeller = ggplot2::label_parsed,
             strip.position = "top", ncol = 1
           )
) + theme_bw(base_size = 12)
```

参数的后验分布

```{r}
#| label: fig-rongelap-gaussian-dens
#| fig-cap: $\sigma$ 和 $\phi$ 的后验分布

mcmc_dens(fit_rongelap_gaussian$draws(c("sigma", "phi")),
          facet_args = list(
            labeller = ggplot2::label_parsed,
            strip.position = "top", ncol = 1
          )
) + theme_bw(base_size = 12)
```

## 代码优化

链内并行、GPU 并行

## 模型评估

-   LOO-CV （Leave-One-Out Cross-Validation，LOO-CV）留一交叉验证，越大越好。
-   WAIC （Widely Available Information Criterion）通用信息准则，越小越好。

### 对数高斯模型

``` stan
generated quantities {
  real log_lik = multi_normal_cholesky_lpdf(y | mu, L_K);
}
```

在 `generated quantities` 代码块中计算逐点对数似然 pointwise log-likelihood。

```{r}
fit_rongelap_gaussian$summary(
  variables = "log_lik",
  .num_args = list(sigfig = 4, notation = "dec")
)
```

每一次采样迭代都会计算一次对数似然 `log_lik`

```{r}
#| label: fig-rongelap-log-lik-gaussian
#| fig-cap: 对数似然
#| fig-width: 6
#| fig-height: 4
#| fig-showtext: true

mcmc_trace(fit_rongelap_gaussian$draws("log_lik")) + 
  theme_bw(base_size = 12)
```

留一交叉验证 Leave-one-out cross-validation (LOO-CV)

```{r}
fit_rongelap_gaussian$loo(variables = "log_lik", cores = 2)
```

```{r}
fit_rongelap_waic <- loo::waic(fit_rongelap_gaussian$draws(variables = "log_lik"))
print(fit_rongelap_waic)
```


## 模型比较

是否高斯分布、指数或高斯协方差函数、是否块金效应、估计方法 ML/REML 4 个维度，对比模型拟合结果

```{r}
library(nlme)
# 高斯分布、指数型自相关结构
fit_exp_reml <- gls(log(counts / time) ~ 1,
  correlation = corExp(value = 200, form = ~ cX + cY, nugget = FALSE),
  data = rongelap, method = "REML"
)
fit_exp_ml <- gls(log(counts / time) ~ 1,
  correlation = corExp(value = 200, form = ~ cX + cY, nugget = FALSE),
  data = rongelap, method = "ML"
)
fit_exp_reml_nugget <- gls(log(counts / time) ~ 1,
  correlation = corExp(value = c(200, 0.1), form = ~ cX + cY, nugget = TRUE),
  data = rongelap, method = "REML"
)
fit_exp_ml_nugget <- gls(log(counts / time) ~ 1,
  correlation = corExp(value = c(200, 0.1), form = ~ cX + cY, nugget = TRUE),
  data = rongelap, method = "ML"
)

# 高斯分布、高斯型自相关结构
fit_gaus_reml <- gls(log(counts / time) ~ 1,
  correlation = corGaus(value = 200, form = ~ cX + cY, nugget = FALSE),
  data = rongelap, method = "REML"
)
fit_gaus_ml <- gls(log(counts / time) ~ 1,
  correlation = corGaus(value = 200, form = ~ cX + cY, nugget = FALSE),
  data = rongelap, method = "ML"
)
fit_gaus_reml_nugget <- gls(log(counts / time) ~ 1,
  correlation = corGaus(value = c(200, 0.1), form = ~ cX + cY, nugget = TRUE),
  data = rongelap, method = "REML"
)
fit_gaus_ml_nugget <- gls(log(counts / time) ~ 1,
  correlation = corGaus(value = c(200, 0.1), form = ~ cX + cY, nugget = TRUE),
  data = rongelap, method = "ML"
)
```

汇总结果见下表 \@ref(tab:gls-summary)。

```{r}
#| label: gls-summary
#| echo: false

dat <- tibble::tribble(
  ~response, ~corr, ~nugget, ~method, ~beta, ~sigmasq, ~phi, ~loglik,
  "高斯分布", "指数型", "无", "REML", "1.826", "0.3172", "110.8", "-89.07",
  "高斯分布", "指数型", "无", "ML", "1.828", "0.3064", "105.4", "-87.56",
  "高斯分布", "指数型", "0.03598", "REML", "1.813", "0.2935", "169.7472", "-88.22",
  "高斯分布", "指数型", "0.03312", "ML", "1.828", "0.2779", "150.1324", "-86.88",
  "高斯分布", "高斯型", "无", "REML", "1.878", "0.2523", "41.96", "-100.7",
  "高斯分布", "高斯型", "无", "ML", "1.879", "0.25", "41.81", "-98.62",
  "高斯分布", "高斯型", "0.07055", "REML", "1.831", "0.2532", "139.1431", "-84.91",
  "高斯分布", "高斯型", "0.07053", "ML", "1.832", "0.2459", "137.0980", "-83.32"
)

knitr::kable(dat, col.names = c(
  "响应变量分布", "空间自相关结构", "块金效应", "估计方法",
  "$\\beta$", "$\\sigma^2$", "$\\phi$", "对数似然值"
  ), caption = "不同模型与参数估计方法的比较", escape = FALSE)
```

相比于其他参数，REML 和 ML 估计方法对参数 $\phi$ 影响很大，ML 估计的 $\phi$ 和对数似然函数值更大。高斯型自相关结构中，REML 和 ML 估计方法对参数 $\phi$ 的估计结果差不多。函数 `gls()` 对初值要求不高，以上初值选取比较随意，只是符合要求函数定义。

## 模型预测

预测位置需要放入 Stan 代码中

### 对数高斯模型

``` stan
generated quantities {
  vector[N] yhat = multi_normal_cholesky_rng(mu, L_K);
}
```

在 `generated quantities` 代码块中计算预测值 `yhat`。

采样点的观测值服从多元正态分布，预测 `yhat`

```{r}
# 对数高斯模型
fit_rongelap_gaussian$summary(
  variables = c("yhat"),
  .num_args = list(sigfig = 4, notation = "dec")
)
```

第一个采样点的预测值

```{r}
fit_rongelap_gaussian$summary(
  variables = "yhat[1]",
  .num_args = list(sigfig = 4, notation = "dec")
)
```

第一个采样点 $\log\{\lambda(x_1)\}$ 的后验预测分布

```{r}
#| label: fig-rongelap-pred-1
#| fig-cap: $\log\{\lambda(x_1)\}$ 处核辐射强度的分布
#| fig-width: 6
#| fig-height: 4
#| fig-showtext: true

mcmc_dens(fit_rongelap_gaussian$draws(variables = "yhat[1]")) + 
  theme_bw(base_size = 12) +
  labs(x = expression(hat(y)[1]))
```

```{r}
# 抽取原始的模拟数据
yhat_gaussian <- fit_rongelap_gaussian$draws(variables = "yhat", format = "array")
# 整理数据
rongelap$yhat <- as.vector(yhat_gaussian[1,1,])
```

拟合值的概览

```{r}
summary(rongelap$yhat / rongelap$time)
```

恢复到辐射强度的尺度，核辐射强度的预测分布

```{r}
#| label: fig-rongelap-pred
#| fig-cap: 核辐射强度的分布
#| fig-width: 7.5
#| fig-height: 4
#| fig-showtext: true

ggplot(data = rongelap, aes(x = cX, y = cY)) +
  geom_point(aes(color = yhat), cex = 0.5) +
  scale_color_distiller(palette = "Spectral") +
  theme_bw() +
  labs(x = "横坐标（米）", y = "纵坐标（米）", color = "预测值")
```

预测结果，看起来很平滑。相比于观测的辐射强度值，预测的辐射强度的变化范围变小很多了。

```{r}
# 贝叶斯预测值范围
range(rongelap$yhat / rongelap$time)
# 观测值范围
range(rongelap$counts / rongelap$time)
```

# 参考文献 {#references}

::: {#refs}
:::

# 附录

目的是将模型/线性代数与 Stan 代码对应。读者熟悉 R 代码后，对同一模型，观察、体会 Stan 代码与 R 代码的异同。Stan 常常是需要和其它编程语言一起混合来完成贝叶斯建模的。在不同编程语言之间切换需要了解它们之间的不同，比如在数据类型、模型表达、矩阵分解等。

## 模拟多元正态分布

下面使用 Cholesky 分解生成多元正态分布随机数，代码稍修改自[《统计计算》](https://www.math.pku.edu.cn/teachers/lidf/docs/statcomp/html/_statcompbook/rng-multi.html)多元随机向量的模拟。

```{r}
# n 样本点的数量
# mu 均值向量
# Sigma 协方差矩阵
rng_mnorm <- function(n, mu, Sigma) {
  m <- length(mu)
  M <- chol(Sigma) # Sigma = M' M
  y <- matrix(rnorm(n * m), nrow = n, ncol = m) %*% M
  apply(y, 1, FUN = function(x) x + mu)
}
set.seed(20232023)
# 1000 个样本点
x <- rng_mnorm(n = 1000, mu = c(3, 2), Sigma = rbind(c(4, 1), c(1, 1)))
# 样本均值
colMeans(t(x))
# 样本协方差矩阵
var(t(x))
```

代码中 $n$ 是样本点的个数，$\bm{\mu}$ 是均值向量，$\Sigma$ 是对称正定协方差阵。

```{r}
#| label: fig-bivar
#| fig-cap: 生成二元正态分布的随机数
#| fig-width: 6
#| fig-height: 4
#| fig-showtext: true
#| echo: false

op <- par(mar = c(4, 4, 1, 1))
plot(x = x[1, ], y = x[2, ],
  col = densCols(t(x),
    bandwidth = c(0.5, 0.5),
    nbin = c(51L, 51L), colramp = hcl.colors
  ),
  type = "p", cex = 0.5, panel.first = grid(),
  xlab = expression(x[1]), ylab = expression(x[2])
)
abline(v = 3, h = 2, col = "gray")
points(x = 3, y = 2, col = "red", pch = 16)
on.exit(par(op), add = TRUE)
```

顺便一提，函数 `MASS::mvrnorm()` 和 `mvtnorm::rmvnorm()` 都可以生成服从多元正态分布的随机数。

## 模拟二维高斯过程

二维高斯过程 $\mathcal{S}$ 的均值向量为 0 向量，自协方差函数为指数型，

$$
\sigma = 10, \phi = 0.1
$$

```{r}
set.seed(20232023)
N <- 15
X <- expand.grid(x1 = 1:N / N, x2 = 1:N / N)
gp_exp_fun <- function(X, sigma, phi) {
  sigma^2 * exp(-as.matrix(dist(X)) / phi)
}
mu <- rep(0, N * N)
# 协方差矩阵
Sigma <- gp_exp_fun(X = X, sigma = 10, phi = 0.1)
sim_gp_data <- as.data.frame(X)
# 模拟高斯过程
sim_gp_data$ysim <- MASS::mvrnorm(1, mu = mu, Sigma = Sigma)
# 样本方差
sd(sim_gp_data$ysim)
```

```{r}
#| label: fig-2d-gp
#| fig-cap: 模拟的二维高斯过程
#| fig-width: 6.5
#| fig-height: 4
#| fig-showtext: true

ggplot(data = sim_gp_data, aes(x = x1, y = x2)) +
  geom_point(aes(color = ysim)) +
  scale_color_distiller(palette = "Spectral") +
  theme_bw() +
  labs(x = expression(x[1]), y = expression(x[2]))
```

