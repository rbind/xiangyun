---
title: 贝叶斯数据分析工作流
author: 黄湘云
date: '2023-10-02'
slug: bayesian-workflow
categories:
  - 统计应用
tags:
  - 贝叶斯空间分析
  - 核辐射强度预测
  - 贝叶斯高斯过程
  - 极大似然估计
  - 广义最小二乘估计
  - 边际似然函数
output:
  blogdown::html_page:
    toc: true
    number_sections: true
link-citations: true
math: true
draft: true
csl: institute-of-mathematical-statistics.csl
bibliography: 
  - refer.bib
description: "贝叶斯数据分析工作流。一文搞懂贝叶斯空间数据分析工作流"
---


<div id="TOC">
<ul>
<li><a href="#本文概览" id="toc-本文概览"><span class="toc-section-number">1</span> 本文概览</a></li>
<li><a href="#工作流" id="toc-工作流"><span class="toc-section-number">2</span> 工作流</a>
<ul>
<li><a href="#统计建模" id="toc-统计建模"><span class="toc-section-number">2.1</span> 统计建模</a></li>
<li><a href="#数据准备" id="toc-数据准备"><span class="toc-section-number">2.2</span> 数据准备</a>
<ul>
<li><a href="#观测数据" id="toc-观测数据"><span class="toc-section-number">2.2.1</span> 观测数据</a></li>
<li><a href="#预测数据" id="toc-预测数据"><span class="toc-section-number">2.2.2</span> 预测数据</a></li>
<li><a href="#初始数据" id="toc-初始数据"><span class="toc-section-number">2.2.3</span> 初始数据</a></li>
</ul></li>
<li><a href="#软件准备" id="toc-软件准备"><span class="toc-section-number">2.3</span> 软件准备</a></li>
<li><a href="#代码编写" id="toc-代码编写"><span class="toc-section-number">2.4</span> 代码编写</a></li>
<li><a href="#代码编译" id="toc-代码编译"><span class="toc-section-number">2.5</span> 代码编译</a></li>
<li><a href="#模型采样" id="toc-模型采样"><span class="toc-section-number">2.6</span> 模型采样</a></li>
<li><a href="#模型输出" id="toc-模型输出"><span class="toc-section-number">2.7</span> 模型输出</a></li>
<li><a href="#模型诊断" id="toc-模型诊断"><span class="toc-section-number">2.8</span> 模型诊断</a></li>
<li><a href="#代码优化" id="toc-代码优化"><span class="toc-section-number">2.9</span> 代码优化</a></li>
<li><a href="#模型评估" id="toc-模型评估"><span class="toc-section-number">2.10</span> 模型评估</a></li>
<li><a href="#模型预测" id="toc-模型预测"><span class="toc-section-number">2.11</span> 模型预测</a></li>
</ul></li>
<li><a href="#references" id="toc-references"><span class="toc-section-number">3</span> 参考文献</a></li>
<li><a href="#附录" id="toc-附录"><span class="toc-section-number">4</span> 附录</a>
<ul>
<li><a href="#模拟多元正态分布" id="toc-模拟多元正态分布"><span class="toc-section-number">4.1</span> 模拟多元正态分布</a></li>
<li><a href="#模拟二维高斯过程" id="toc-模拟二维高斯过程"><span class="toc-section-number">4.2</span> 模拟二维高斯过程</a></li>
</ul></li>
</ul>
</div>

<div class="rmdtip">
<ol style="list-style-type: decimal">
<li>贝叶斯高斯过程回归和贝叶斯泊松过程回归</li>
<li>核辐射数据集的贝叶斯分析</li>
<li>贝叶斯简单克里金插值及 Stan 实现</li>
</ol>
</div>
<div id="本文概览" class="section level1" number="1">
<h1><span class="header-section-number">1</span> 本文概览</h1>
<ol style="list-style-type: decimal">
<li>本文概览：贝叶斯数据分析工作流的概览</li>
<li>以预测朗格拉普岛核辐射强度分布为例，详细介绍贝叶斯工作流中的各个环节。
<ol style="list-style-type: decimal">
<li>统计建模：模型结构、组成部分、参数解释</li>
<li>数据准备：观测数据、预测数据、参数初值</li>
<li>软件准备：软件环境</li>
<li>代码编写：已有函数及其解释</li>
<li>代码编译：编译选项及解释</li>
<li>模型采样：采样算法简介，NUTS 算法参数说明</li>
<li>模型输出：模型采样输出结果的说明和解释，</li>
<li>模型诊断：参数迭代轨迹和分布，诊断结果</li>
<li>代码优化：根据诊断结果优化，比如并行和向量化</li>
<li>模型评估：pDIC、WAIC、LOO-CV</li>
<li>模型比较：泊松对数、对数高斯建模比较</li>
<li>模型预测：克里金插值预测</li>
</ol></li>
<li>本文小结：
<ol style="list-style-type: decimal">
<li>分析、建模经验</li>
<li>Stan 代码调优</li>
</ol></li>
</ol>
</div>
<div id="工作流" class="section level1" number="2">
<h1><span class="header-section-number">2</span> 工作流</h1>
<p>本文主要参考《Bayesian Workflow》 <span class="citation">[<a href="#ref-Gelman2020">1</a>]</span></p>
<div id="统计建模" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> 统计建模</h2>
<p>相邻位置的核辐射强度是相关的，离得近的比离得远的更相关。下面对辐射强度建模，假定随机效应之间存在相关性结构，去掉随机效应相互独立的假设，这更符合位置效应存在相互影响的实际情况。</p>
<p><span class="math display">\[
\log\big\{\lambda(x_i)\big\} = \beta + S(x_{i})
\]</span></p>
<p>其中，<span class="math inline">\(\beta\)</span> 表示截距，相当于平均水平，<span class="math inline">\(\lambda(x_i)\)</span> 表示位置 <span class="math inline">\(x_i\)</span> 处的辐射强度，<span class="math inline">\(S(x_{i})\)</span> 表示位置 <span class="math inline">\(x_i\)</span> 处的空间效应，<span class="math inline">\(S(x),x \in \mathcal{D} \subset{\mathbb{R}^2}\)</span> 是二维平稳空间高斯过程 <span class="math inline">\(\mathcal{S}\)</span> 的具体实现。 <span class="math inline">\(\mathcal{D}\)</span> 表示研究区域，可以理解为朗格拉普岛，它是二维实平面 <span class="math inline">\(\mathbb{R}^2\)</span> 的子集。</p>
</div>
<div id="数据准备" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> 数据准备</h2>
<div id="观测数据" class="section level3" number="2.2.1">
<h3><span class="header-section-number">2.2.1</span> 观测数据</h3>
<pre class="r"><code># 加载数据
rongelap &lt;- readRDS(file = &quot;data/rongelap.rds&quot;)
rongelap_coastline &lt;- readRDS(file = &quot;data/rongelap_coastline.rds&quot;)</code></pre>
</div>
<div id="预测数据" class="section level3" number="2.2.2">
<h3><span class="header-section-number">2.2.2</span> 预测数据</h3>
<pre class="r"><code>library(sf)
library(abind)
library(stars)

rongelap_sf &lt;- st_as_sf(rongelap, coords = c(&quot;cX&quot;, &quot;cY&quot;), dim = &quot;XY&quot;)
rongelap_coastline_sf &lt;- st_as_sf(rongelap_coastline, coords = c(&quot;cX&quot;, &quot;cY&quot;), dim = &quot;XY&quot;)
rongelap_coastline_sfp &lt;- st_cast(st_combine(st_geometry(rongelap_coastline_sf)), &quot;POLYGON&quot;)

rongelap_coastline_buffer &lt;- st_buffer(rongelap_coastline_sfp, dist = 50)
# 构造带边界约束的网格
rongelap_coastline_grid &lt;- st_make_grid(rongelap_coastline_buffer, n = c(150, 75))
# 将 sfc 类型转化为 sf 类型
rongelap_coastline_grid &lt;- st_as_sf(rongelap_coastline_grid)
rongelap_coastline_buffer &lt;- st_as_sf(rongelap_coastline_buffer)
rongelap_grid &lt;- rongelap_coastline_grid[rongelap_coastline_buffer, op = st_intersects]
# 计算网格中心点坐标
rongelap_grid_centroid &lt;- st_centroid(rongelap_grid)

# 1612 个点
rongelap_grid_df &lt;- as.data.frame(st_coordinates(rongelap_grid_centroid))
colnames(rongelap_grid_df) &lt;- c(&quot;cX&quot;, &quot;cY&quot;)</code></pre>
<p><code>rongelap_grid_df</code> 即为需要预测核辐射强度的位置</p>
</div>
<div id="初始数据" class="section level3" number="2.2.3">
<h3><span class="header-section-number">2.2.3</span> 初始数据</h3>
<p>对数高斯模型</p>
<pre class="r"><code>set.seed(20232023)
nchains &lt;- 2 # 2 条迭代链
# 给每条链设置不同的参数初始值
inits_data_gaussian &lt;- lapply(1:nchains, function(i) {
  list(
    beta = rnorm(1),
    sigma = runif(1),
    phi = runif(1),
    tau = runif(1)
  )
})

# 对数高斯模型
rongelap_gaussian_d &lt;- list(
  N1 = nrow(rongelap), # 观测记录的条数
  N2 = nrow(rongelap_grid_df),
  D = 2, # 2 维坐标
  x1 = rongelap[, c(&quot;cX&quot;, &quot;cY&quot;)] / 6000, # N x 2 坐标矩阵
  x2 = rongelap_grid_df[, c(&quot;cX&quot;, &quot;cY&quot;)] / 6000,
  y1 = log(rongelap$counts / rongelap$time) # N 向量
)</code></pre>
</div>
</div>
<div id="软件准备" class="section level2" number="2.3">
<h2><span class="header-section-number">2.3</span> 软件准备</h2>
<p>下载、编译 CmdStan 软件框架，配置环境变量</p>
<pre class="r"><code>Sys.setenv(CMDSTAN = &quot;/opt/cmdstan/cmdstan-2.32.2&quot;)
Sys.setenv(CMDSTANR_NO_VER_CHECK = TRUE)</code></pre>
<p>加载 <strong>cmdstanr</strong>、<strong>bayesplot</strong> 和 <strong>loo</strong> 等 R 包。</p>
<pre class="r"><code>library(cmdstanr)
library(ggplot2)
library(bayesplot)
library(loo)</code></pre>
<ul>
<li><strong>cmdstanr</strong> 配置 Stan 环境、编译 Stan 代码（设置编译参数）和采样（设置采样算法和参数）。</li>
<li><strong>bayesplot</strong> <span class="citation">[<a href="#ref-Gabry2019">2</a>]</span> 可视化模型参数的后验分布，迭代轨迹的散点图、迭代链的自相关图、后验分布的直方图等。</li>
<li><strong>loo</strong> 模型评估与比较，计算 LOO 和 WAIC 等指标。</li>
<li><strong>projpred</strong> 变量选择</li>
<li><strong>posterior</strong> 后验推断</li>
</ul>
</div>
<div id="代码编写" class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> 代码编写</h2>
<p><span class="math display">\[
\begin{aligned}
\beta &amp;\sim \text{std_normal}(0,1) \\
\sigma &amp;\sim \text{inv_gamma}(5,5) \\
\phi &amp;\sim \text{half_std_normal}(0,1) \\
\bm{y} &amp;\sim \text{multivariate_normal}(\bm{\beta}, \sigma^2 \Sigma+ \delta^2 I)
\end{aligned}
\]</span></p>
<p>其中，<span class="math inline">\(\beta\)</span> 代表截距，先验分布为标准正态分布，<span class="math inline">\(\sigma\)</span> 代表高斯过程的方差参数（信号），先验分布为逆伽马分布，<span class="math inline">\(\phi\)</span> 代表高斯过程的范围参数，先验分布为半标准正态分布，<span class="math inline">\(y\)</span> 代表响应变量的取值，给定参数和数据的条件分布为多元正态分布，<span class="math inline">\(\Sigma\)</span> 代表协方差矩阵，<span class="math inline">\(I\)</span> 代表与采样点数量相同的单位矩阵， <span class="math inline">\(\delta\)</span> 是非常小的常数（可以看作可忽略的噪声），使得协方差矩阵正定，确保 Cholesky 分解。</p>
<pre class="stan"><code>functions {
  vector gp_pred_rng(array[] vector x2,
                     vector y1,
                     array[] vector x1,
                     real sigma,
                     real phi,
                     real tau,
                     real delta) {
    int N1 = rows(y1);
    int N2 = size(x2);
    vector[N2] f2;
    {
      matrix[N1, N1] L_K;
      vector[N1] K_div_y1;
      matrix[N1, N2] k_x1_x2;
      matrix[N1, N2] v_pred;
      vector[N2] f2_mu;
      matrix[N2, N2] cov_f2;
      matrix[N2, N2] diag_delta;
      matrix[N1, N1] K;
      K = gp_exponential_cov(x1, sigma, phi);
      for (n in 1:N1) {
        K[n, n] = K[n, n] + square(tau);
      }
      L_K = cholesky_decompose(K);
      K_div_y1 = mdivide_left_tri_low(L_K, y1);
      K_div_y1 = mdivide_right_tri_low(K_div_y1&#39;, L_K)&#39;;
      k_x1_x2 = gp_exponential_cov(x1, x2, sigma, phi);
      f2_mu = (k_x1_x2&#39; * K_div_y1);
      v_pred = mdivide_left_tri_low(L_K, k_x1_x2);
      cov_f2 = gp_exponential_cov(x2, sigma, phi) - v_pred&#39; * v_pred;
      diag_delta = diag_matrix(rep_vector(delta, N2));

      f2 = multi_normal_rng(f2_mu, cov_f2 + diag_delta);
    }
    return f2;
  }
}
data {
  int&lt;lower=1&gt; D;
  int&lt;lower=1&gt; N1;
  array[N1] vector[D] x1;
  vector[N1] y1;
  int&lt;lower=1&gt; N2;
  array[N2] vector[D] x2;
}
transformed data {
  real delta = 1e-9;
}
parameters {
  real beta;
  real&lt;lower=0&gt; phi;
  real&lt;lower=0&gt; sigma;
  real&lt;lower=0&gt; tau;
}
transformed parameters {
  vector[N1] mu = rep_vector(beta, N1);
}
model {
  matrix[N1, N1] L_K;
  {
    matrix[N1, N1] K = gp_exponential_cov(x1, sigma, phi);
    real sq_tau = square(tau);

    // diagonal elements
    for (n1 in 1:N1) {
      K[n1, n1] = K[n1, n1] + sq_tau;
    }

    L_K = cholesky_decompose(K);
  }

  beta ~ std_normal();
  phi ~ std_normal();
  sigma ~ inv_gamma(5, 5);
  tau ~ std_normal();

  y1 ~ multi_normal_cholesky(mu, L_K);
}
generated quantities {
  vector[N2] f2;
  vector[N2] ypred;

  f2 = gp_pred_rng(x2, y1, x1, sigma, phi, tau, delta);
  for (n2 in 1:N2) {
    ypred[n2] = normal_rng(f2[n2], tau);
  }
}</code></pre>
<p>代码中，<code>gp_exponential_cov</code> 表示空间相关性结构选择了指数型，详见 Stan 函数手册中的<a href="https://mc-stan.org/docs/functions-reference/gaussian-process-covariance-functions.html#exponential-kernel">指数型核函数表示</a>。<code>cholesky_decompose</code> 表示对协方差矩阵做 Cholesky 分解，分解出来的下三角矩阵作为多元正态分布的参数，详见 Stan 函数手册中的 <a href="https://mc-stan.org/docs/functions-reference/linear-algebra-functions-and-solvers.html#cholesky-decomposition">Cholesky 分解</a>。 <code>multi_normal_cholesky</code> 表示基于 Cholesky 分解的多元正态分布。详见 Stan 函数手册中的多元正态分布的 <a href="https://mc-stan.org/docs/functions-reference/multi-normal-cholesky-fun.html">Cholesky</a> 参数化表示。</p>
</div>
<div id="代码编译" class="section level2" number="2.5">
<h2><span class="header-section-number">2.5</span> 代码编译</h2>
<p>编译模型</p>
<pre class="r"><code>mod_rongelap_gaussian &lt;- cmdstan_model(
  stan_file = &quot;code/rongelap_gaussian_pred.stan&quot;,
  compile = TRUE, cpp_options = list(stan_threads = TRUE)
)</code></pre>
</div>
<div id="模型采样" class="section level2" number="2.6">
<h2><span class="header-section-number">2.6</span> 模型采样</h2>
<p>拟合模型</p>
<pre class="r"><code># 对数高斯模型
fit_rongelap_gaussian &lt;- mod_rongelap_gaussian$sample(
  data = rongelap_gaussian_d,   # 观测数据
  init = inits_data_gaussian,   # 迭代初值
  iter_warmup = 500,           # 每条链预处理迭代次数
  iter_sampling = 1000,         # 每条链总迭代次数
  chains = nchains,             # 马尔科夫链的数目
  parallel_chains = 2,      # 指定 CPU 核心数，可以给每条链分配一个
  threads_per_chain = 1,    # 每条链设置一个线程
  show_messages = FALSE,    # 不显示迭代的中间过程
  refresh = 0,              # 不显示采样的进度
  output_dir = &quot;data/&quot;,
  seed = 20232023           # 设置随机数种子，不要使用 set.seed() 函数
)</code></pre>
<pre class="r"><code># 诊断
fit_rongelap_gaussian$diagnostic_summary()
#&gt; $num_divergent
#&gt; [1] 0 0
#&gt; 
#&gt; $num_max_treedepth
#&gt; [1] 0 0
#&gt; 
#&gt; $ebfmi
#&gt; [1] 1.098 1.152</code></pre>
</div>
<div id="模型输出" class="section level2" number="2.7">
<h2><span class="header-section-number">2.7</span> 模型输出</h2>
<p>模型参数的估计结果，输出结果保留 4 位有效数字。</p>
<pre class="r"><code># 对数高斯模型
fit_rongelap_gaussian$summary(
  variables = c(&quot;lp__&quot;, &quot;beta&quot;, &quot;sigma&quot;, &quot;phi&quot;),
  .num_args = list(sigfig = 4, notation = &quot;dec&quot;)
)
#&gt; # A tibble: 4 × 10
#&gt;   variable    mean  median     sd    mad       q5    q95  rhat ess_bulk ess_tail
#&gt;   &lt;chr&gt;    &lt;dec:4&gt; &lt;dec:4&gt; &lt;dec:&gt; &lt;dec:&gt;  &lt;dec:4&gt; &lt;dec:&gt; &lt;dec&gt;  &lt;dec:4&gt;  &lt;dec:4&gt;
#&gt; 1 lp__     42.54   42.85   1.386  1.258  39.88    44.16  1.001    565.1    702.4
#&gt; 2 beta      1.081   1.281  0.7693 0.7237 -0.4013   1.944 1.002    479.5    620.5
#&gt; 3 sigma     1.148   1.064  0.4927 0.5198  0.5491   2.078 1.002    316.7    732.1
#&gt; 4 phi       0.3877  0.2755 0.3775 0.3068  0.02714  1.143 1.000    255.0    206.7</code></pre>
<div class="rmdtip">
<p>作为对比，提供频率派参数估计结果，采用 <strong>nlme</strong> 包拟合对数高斯模型。</p>
<pre class="r"><code>library(nlme)
fit_rongelap_nlme &lt;- gls(log(counts / time) ~ 1,
  correlation = corExp(value = 200, form = ~ cX + cY, nugget = FALSE),
  data = rongelap, method = &quot;REML&quot;
)
fit_rongelap_nlme
#&gt; Generalized least squares fit by REML
#&gt;   Model: log(counts/time) ~ 1 
#&gt;   Data: rongelap 
#&gt;   Log-restricted-likelihood: -89.07
#&gt; 
#&gt; Coefficients:
#&gt; (Intercept) 
#&gt;       1.826 
#&gt; 
#&gt; Correlation Structure: Exponential spatial correlation
#&gt;  Formula: ~cX + cY 
#&gt;  Parameter estimate(s):
#&gt; range 
#&gt; 110.8 
#&gt; Degrees of freedom: 157 total; 156 residual
#&gt; Residual standard error: 0.5632</code></pre>
<p>结果显示 <span class="math inline">\(\beta = 1.826, \phi = 110.8, \sigma^2 = 0.5632^2 = 0.3172\)</span> 。</p>
</div>
</div>
<div id="模型诊断" class="section level2" number="2.8">
<h2><span class="header-section-number">2.8</span> 模型诊断</h2>
<pre class="r"><code>library(ggplot2)
library(bayesplot)
mcmc_trace(fit_rongelap_gaussian$draws(c(&quot;sigma&quot;, &quot;phi&quot;)),
           facet_args = list(
             labeller = ggplot2::label_parsed,
             strip.position = &quot;top&quot;, ncol = 1
           )
) + theme_bw(base_size = 12)</code></pre>
<div class="figure"><span style="display:block;" id="fig:fig-rongelap-gaussian-trace"></span>
<img src="{{< blogdown/postref >}}index_files/figure-html/fig-rongelap-gaussian-trace-1.png" alt="$\sigma$ 和 $\phi$ 的迭代轨迹" width="672" />
<p class="caption">
图 2.1: <span class="math inline">\(\sigma\)</span> 和 <span class="math inline">\(\phi\)</span> 的迭代轨迹
</p>
</div>
<p>参数的后验分布</p>
<pre class="r"><code>mcmc_dens(fit_rongelap_gaussian$draws(c(&quot;sigma&quot;, &quot;phi&quot;)),
          facet_args = list(
            labeller = ggplot2::label_parsed,
            strip.position = &quot;top&quot;, ncol = 1
          )
) + theme_bw(base_size = 12)</code></pre>
<div class="figure"><span style="display:block;" id="fig:fig-rongelap-gaussian-dens"></span>
<img src="{{< blogdown/postref >}}index_files/figure-html/fig-rongelap-gaussian-dens-1.png" alt="$\sigma$ 和 $\phi$ 的后验分布" width="672" />
<p class="caption">
图 2.2: <span class="math inline">\(\sigma\)</span> 和 <span class="math inline">\(\phi\)</span> 的后验分布
</p>
</div>
</div>
<div id="代码优化" class="section level2" number="2.9">
<h2><span class="header-section-number">2.9</span> 代码优化</h2>
<p>链内并行、GPU 并行</p>
</div>
<div id="模型评估" class="section level2" number="2.10">
<h2><span class="header-section-number">2.10</span> 模型评估</h2>
<ul>
<li>LOO-CV （Leave-One-Out Cross-Validation，LOO-CV）留一交叉验证，越大越好。</li>
<li>WAIC （Widely Available Information Criterion）通用信息准则，越小越好。</li>
</ul>
<pre class="stan"><code>generated quantities {
  vector[N2] f2;
  vector[N2] ypred;

  f2 = gp_pred_rng(x2, y1, x1, sigma, phi, tau, delta);
  for (n2 in 1:N2) {
    ypred[n2] = normal_rng(f2[n2], tau);
  }
}</code></pre>
<p>在 <code>generated quantities</code> 代码块中计算预测值 ypred。</p>
<pre class="r"><code>fit_rongelap_gaussian$summary(
  variables = &quot;ypred[1]&quot;,
  .num_args = list(sigfig = 4, notation = &quot;dec&quot;)
)
#&gt; # A tibble: 1 × 10
#&gt;   variable    mean  median      sd     mad      q5   q95  rhat ess_bulk ess_tail
#&gt;   &lt;chr&gt;    &lt;dec:4&gt; &lt;dec:4&gt; &lt;dec:4&gt; &lt;dec:4&gt; &lt;dec:4&gt; &lt;dec&gt; &lt;dec&gt;  &lt;dec:4&gt;  &lt;dec:4&gt;
#&gt; 1 ypred[1]   1.394   1.412  0.6684  0.6695  0.2434 2.464 1.000    812.3    926.2</code></pre>
</div>
<div id="模型预测" class="section level2" number="2.11">
<h2><span class="header-section-number">2.11</span> 模型预测</h2>
<p>预测位置需要放入 Stan 代码中，采样点的观测值服从多元正态分布，预测 <code>ypred</code></p>
<p>第一个采样点 <span class="math inline">\(\log\{\lambda(x_1)\}\)</span> 的后验预测分布</p>
<pre class="r"><code>mcmc_dens(fit_rongelap_gaussian$draws(variables = &quot;ypred[1]&quot;)) + 
  theme_bw(base_size = 12) +
  labs(x = expression(ypred[1]))</code></pre>
<div class="figure"><span style="display:block;" id="fig:fig-rongelap-pred-1"></span>
<img src="{{< blogdown/postref >}}index_files/figure-html/fig-rongelap-pred-1-1.png" alt="$\log\{\lambda(x_1)\}$ 处核辐射强度的分布" width="576" />
<p class="caption">
图 2.3: <span class="math inline">\(\log\{\lambda(x_1)\}\)</span> 处核辐射强度的分布
</p>
</div>
<pre class="r"><code># 抽取原始的模拟数据
ypred &lt;- fit_rongelap_gaussian$summary(variables = &quot;ypred&quot;, &quot;mean&quot;)
# 整理数据
rongelap_grid_df$ypred &lt;- exp(ypred$mean)</code></pre>
<p>拟合值的概览</p>
<pre class="r"><code>summary(rongelap_grid_df$ypred)
#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#&gt;   0.667   4.931   6.112   6.031   7.283  10.513</code></pre>
<p>恢复到辐射强度的尺度，核辐射强度的预测分布</p>
<pre class="r"><code>ggplot(data = rongelap_grid_df, aes(x = cX, y = cY)) +
  geom_point(aes(color = ypred), cex = 0.5) +
  scale_color_viridis_c(option = &quot;C&quot;, breaks = 3*0:4) +
  theme_bw() +
  labs(x = &quot;横坐标（米）&quot;, y = &quot;纵坐标（米）&quot;, color = &quot;预测值&quot;)</code></pre>
<div class="figure"><span style="display:block;" id="fig:fig-rongelap-pred1"></span>
<img src="{{< blogdown/postref >}}index_files/figure-html/fig-rongelap-pred1-1.png" alt="核辐射强度的分布" width="720" />
<p class="caption">
图 2.4: 核辐射强度的分布
</p>
</div>
<p>预测结果，看起来很平滑。相比于观测的辐射强度值，预测的辐射强度的变化范围变小很多了。</p>
<pre class="r"><code># 贝叶斯预测值范围
range(rongelap_grid_df$ypred)
#&gt; [1]  0.6675 10.5126
# 观测值范围
range(rongelap$counts / rongelap$time)
#&gt; [1]  0.25 15.10</code></pre>
<pre class="r"><code>rongelap_grid_sf &lt;- st_as_sf(rongelap_grid_df, coords = c(&quot;cX&quot;, &quot;cY&quot;), dim = &quot;XY&quot;)
rongelap_grid_stars &lt;- st_rasterize(rongelap_grid_sf, nx = 150, ny = 75)
rongelap_stars &lt;- st_crop(x = rongelap_grid_stars, y = rongelap_coastline_sfp)</code></pre>
<pre class="r"><code># 虚线框数据
dash_sfp &lt;- st_polygon(x = list(rbind(
  c(-6000, -3600),
  c(-6000, -2600),
  c(-5000, -2600),
  c(-5000, -3600),
  c(-6000, -3600)
)), dim = &quot;XY&quot;)
# 主体内容
p3 &lt;- ggplot() +
  geom_stars(
    data = rongelap_stars, na.action = na.omit,
    aes(fill = ypred)
  ) +
  # 海岸线
  geom_sf(
    data = rongelap_coastline_sfp,
    fill = NA, color = &quot;gray30&quot;, linewidth = 0.5
  ) +
  # 图例
  scale_fill_viridis_c(
    option = &quot;C&quot;, breaks = 0:12,
    guide = guide_colourbar(
      barwidth = 15, barheight = 1.5,
      title.position = &quot;top&quot; # 图例标题位于图例上方
    )
  ) +
  # 虚线框
  geom_sf(data = dash_sfp, fill = NA, linewidth = 0.75, lty = 2) +
  # 箭头
  geom_segment(
    data = data.frame(x = -5500, xend = -5000, y = -2600, yend = -2250),
    aes(x = x, y = y, xend = xend, yend = yend),
    arrow = arrow(length = unit(0.03, &quot;npc&quot;))
  ) +
  theme_bw() +
  labs(x = &quot;横坐标（米）&quot;, y = &quot;纵坐标（米）&quot;, fill = &quot;辐射强度&quot;) +
  theme(
    legend.position = c(0.75, 0.1),
    legend.direction = &quot;horizontal&quot;,
    legend.background = element_blank()
  )

p4 &lt;- ggplot() +
  geom_stars(
    data = rongelap_stars, na.action = na.omit,
    aes(fill = ypred), show.legend = FALSE
  ) +
  geom_sf(
    data = rongelap_coastline_sfp,
    fill = NA, color = &quot;gray30&quot;, linewidth = 0.75
  ) +
  scale_fill_viridis_c(option = &quot;C&quot;, breaks = 0:12) +
  # 虚线框
  geom_sf(data = dash_sfp, fill = NA, linewidth = 0.75, lty = 2) +
  theme_void() +
  coord_sf(expand = FALSE, xlim = c(-6000, -5000), ylim = c(-3600, -2600))
# 叠加图形
p3
print(p4, vp = grid::viewport(x = .3, y = .65, width = .45, height = .45))</code></pre>
<div class="figure"><span style="display:block;" id="fig:fig-rongelap-pred2"></span>
<img src="{{< blogdown/postref >}}index_files/figure-html/fig-rongelap-pred2-1.png" alt="核辐射强度的分布" width="720" />
<p class="caption">
图 2.5: 核辐射强度的分布
</p>
</div>
</div>
</div>
<div id="references" class="section level1" number="3">
<h1><span class="header-section-number">3</span> 参考文献</h1>
<div id="refs" class="references csl-bib-body">
<div id="ref-Gelman2020" class="csl-entry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline"><span class="smallcaps">Gelman</span>, A., <span class="smallcaps">Vehtari</span>, A., <span class="smallcaps">Simpson</span>, D., <span class="smallcaps">Margossian</span>, C. C., <span class="smallcaps">Carpenter</span>, B., <span class="smallcaps">Yao</span>, Y., <span class="smallcaps">Kennedy</span>, L., <span class="smallcaps">Gabry</span>, J., <span class="smallcaps">Bürkner</span>, P.-C. and <span class="smallcaps">Modrák</span>, M. (2020). <a href="https://arxiv.org/abs/2011.01808">Bayesian workflow</a>.</div>
</div>
<div id="ref-Gabry2019" class="csl-entry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline"><span class="smallcaps">Gabry</span>, J., <span class="smallcaps">Simpson</span>, D., <span class="smallcaps">Vehtari</span>, A., <span class="smallcaps">Betancourt</span>, M. and <span class="smallcaps">Gelman</span>, A. (2019). <a href="https://doi.org/10.1111/rssa.12378">Visualization in bayesian workflow</a>. <em>J. R. Stat. Soc. A</em> <strong>182</strong> 389–402.</div>
</div>
</div>
</div>
<div id="附录" class="section level1" number="4">
<h1><span class="header-section-number">4</span> 附录</h1>
<p>目的是将模型/线性代数与 Stan 代码对应。读者熟悉 R 代码后，对同一模型，观察、体会 Stan 代码与 R 代码的异同。Stan 常常是需要和其它编程语言一起混合来完成贝叶斯建模的。在不同编程语言之间切换需要了解它们之间的不同，比如在数据类型、模型表达、矩阵分解等。</p>
<div id="模拟多元正态分布" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> 模拟多元正态分布</h2>
<p>下面使用 Cholesky 分解生成多元正态分布随机数，代码稍修改自<a href="https://www.math.pku.edu.cn/teachers/lidf/docs/statcomp/html/_statcompbook/rng-multi.html">《统计计算》</a>多元随机向量的模拟。</p>
<pre class="r"><code># n 样本点的数量
# mu 均值向量
# Sigma 协方差矩阵
rng_mnorm &lt;- function(n, mu, Sigma) {
  m &lt;- length(mu)
  M &lt;- chol(Sigma) # Sigma = M&#39; M
  y &lt;- matrix(rnorm(n * m), nrow = n, ncol = m) %*% M
  apply(y, 1, FUN = function(x) x + mu)
}
set.seed(20232023)
# 1000 个样本点
x &lt;- rng_mnorm(n = 1000, mu = c(3, 2), Sigma = rbind(c(4, 1), c(1, 1)))
# 样本均值
colMeans(t(x))
#&gt; [1] 3.112 1.992
# 样本协方差矩阵
var(t(x))
#&gt;       [,1]  [,2]
#&gt; [1,] 3.996 1.029
#&gt; [2,] 1.029 1.019</code></pre>
<p>代码中 <span class="math inline">\(n\)</span> 是样本点的个数，<span class="math inline">\(\bm{\mu}\)</span> 是均值向量，<span class="math inline">\(\Sigma\)</span> 是对称正定协方差阵。</p>
<div class="figure"><span style="display:block;" id="fig:fig-bivar"></span>
<img src="{{< blogdown/postref >}}index_files/figure-html/fig-bivar-1.png" alt="生成二元正态分布的随机数" width="576" />
<p class="caption">
图 4.1: 生成二元正态分布的随机数
</p>
</div>
<p>顺便一提，函数 <code>MASS::mvrnorm()</code> 和 <code>mvtnorm::rmvnorm()</code> 都可以生成服从多元正态分布的随机数。</p>
</div>
<div id="模拟二维高斯过程" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> 模拟二维高斯过程</h2>
<p>二维高斯过程 <span class="math inline">\(\mathcal{S}\)</span> 的均值向量为 0 向量，自协方差函数为指数型，</p>
<p><span class="math display">\[
\sigma = 10, \phi = 0.1
\]</span></p>
<pre class="r"><code>set.seed(20232023)
N &lt;- 15
X &lt;- expand.grid(x1 = 1:N / N, x2 = 1:N / N)
gp_exp_fun &lt;- function(X, sigma, phi) {
  sigma^2 * exp(-as.matrix(dist(X)) / phi)
}
mu &lt;- rep(0, N * N)
# 协方差矩阵
Sigma &lt;- gp_exp_fun(X = X, sigma = 10, phi = 0.1)
sim_gp_data &lt;- as.data.frame(X)
# 模拟高斯过程
sim_gp_data$ysim &lt;- MASS::mvrnorm(1, mu = mu, Sigma = Sigma)
# 样本方差
sd(sim_gp_data$ysim)
#&gt; [1] 9.846</code></pre>
<pre class="r"><code>ggplot(data = sim_gp_data, aes(x = x1, y = x2)) +
  geom_point(aes(color = ysim)) +
  scale_color_distiller(palette = &quot;Spectral&quot;) +
  theme_bw() +
  labs(x = expression(x[1]), y = expression(x[2]))</code></pre>
<div class="figure"><span style="display:block;" id="fig:fig-2d-gp"></span>
<img src="{{< blogdown/postref >}}index_files/figure-html/fig-2d-gp-1.png" alt="模拟的二维高斯过程" width="624" />
<p class="caption">
图 4.2: 模拟的二维高斯过程
</p>
</div>
</div>
</div>
