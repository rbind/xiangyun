---
title: "SciPy 做科学计算"
author: "黄湘云"
date: '2025-10-18'
slug: scipy
categories:
  - 统计软件
tags:
  - numpy
  - scipy
  - matrix
  - array
output:
  blogdown::html_page:
    toc: true
    number_sections: true
link-citations: true
description: "Python 模块 SciPy 是做科学计算的，本文添加等价 R 代码。"
---


<div id="TOC">
<ul>
<li><a href="#%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0" id="toc-线性代数"><span class="toc-section-number">1</span> 线性代数</a></li>
<li><a href="#%E7%A7%AF%E5%88%86" id="toc-积分"><span class="toc-section-number">2</span> 积分</a></li>
<li><a href="#%E4%BC%98%E5%8C%96" id="toc-优化"><span class="toc-section-number">3</span> 优化</a></li>
<li><a href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84" id="toc-稀疏数组"><span class="toc-section-number">4</span> 稀疏数组</a></li>
<li><a href="#%E7%BB%9F%E8%AE%A1" id="toc-统计"><span class="toc-section-number">5</span> 统计</a></li>
</ul>
</div>

<style type="text/css">
.columns {
  display: flex;
}
</style>
<p><a href="https://scipy.org">SciPy</a> 是基于 NumPy 做科学计算的 Python 模块，它的官网没有类似 NumPy 和 Pandas 的快速入门文档，但有一个按功能分类的<a href="https://docs.scipy.org/doc/scipy/tutorial/index.html#user-guide">用户指南</a>。本文介绍 SciPy 提供的基础算法，涵盖优化、积分、插值、特征值问题、代数方程、微分方程、统计学等功能。</p>
<p>下面蜻蜓点水式地介绍一点 SciPy 做科学计算及等价 R 语言实现。</p>
<div id="线性代数" class="section level2" number="1">
<h2><span class="header-section-number">1</span> 线性代数</h2>
<p>在线性代数运算方面，scipy.linalg 包含 <a href="https://www.numpy.org/devdocs/reference/routines.linalg.html">numpy.linalg</a> 的所有函数，且功能比 numpy.linalg 更多。scipy.linalg 总是添加了 BLAS/LAPACK 支持，而这在 numpy.linalg 是可选的。</p>
<p>推荐使用 NumPy 提供的多维数组类型。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>import numpy as np
from scipy import linalg
A = np.array([[1,2],[3,4]])
A</code></pre>
<pre><code>## array([[1, 2],
##        [3, 4]])</code></pre>
<pre class="python"><code>linalg.inv(A)</code></pre>
<pre><code>## array([[-2. ,  1. ],
##        [ 1.5, -0.5]])</code></pre>
<pre class="python"><code>b = np.array([[5,6]]) #2D array
b</code></pre>
<pre><code>## array([[5, 6]])</code></pre>
<pre class="python"><code>b.T</code></pre>
<pre><code>## array([[5],
##        [6]])</code></pre>
<pre class="python"><code>A*b #not matrix multiplication!</code></pre>
<pre><code>## array([[ 5, 12],
##        [15, 24]])</code></pre>
<pre class="python"><code>A.dot(b.T) #matrix multiplication</code></pre>
<pre><code>## array([[17],
##        [39]])</code></pre>
<pre class="python"><code>b = np.array([5,6]) #1D array
b</code></pre>
<pre><code>## array([5, 6])</code></pre>
<pre class="python"><code>b.T  #not matrix transpose!</code></pre>
<pre><code>## array([5, 6])</code></pre>
<pre class="python"><code>A.dot(b)  #does not matter for multiplication</code></pre>
<pre><code>## array([17, 39])</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>A = array(data = c(1, 3, 2, 4), dim = c(2, 2))
A</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4</code></pre>
<pre class="r"><code>solve(A)</code></pre>
<pre><code>##      [,1] [,2]
## [1,] -2.0  1.0
## [2,]  1.5 -0.5</code></pre>
<pre class="r"><code>b = array(data = c(5, 6), dim = c(1, 2))
b</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    5    6</code></pre>
<pre class="r"><code>t(b)</code></pre>
<pre><code>##      [,1]
## [1,]    5
## [2,]    6</code></pre>
<pre class="r"><code># A * b 不可以
A %*% t(b) # 矩阵乘法</code></pre>
<pre><code>##      [,1]
## [1,]   17
## [2,]   39</code></pre>
</div>
</div>
</div>
<div id="积分" class="section level2" number="2">
<h2><span class="header-section-number">2</span> 积分</h2>
<p>这是一个关于贝塞尔函数的积分，贝塞尔函数是内置的特殊函数。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>import scipy.integrate as integrate
import scipy.special as special
result = integrate.quad(lambda x: special.jv(2.5,x), 0, 4.5)
result</code></pre>
<pre><code>## (1.1178179380783249, 7.866317216380692e-09)</code></pre>
<pre class="python"><code>from numpy import sqrt, sin, cos, pi
I = sqrt(2/pi)*(18.0/27*sqrt(2)*cos(4.5) - 4.0/27*sqrt(2)*sin(4.5) +
                sqrt(2*pi) * special.fresnel(3/sqrt(pi))[0])
I</code></pre>
<pre><code>## np.float64(1.117817938088701)</code></pre>
<pre class="python"><code>print(abs(result[0]-I))</code></pre>
<pre><code>## 1.0376144388146713e-11</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>integrate(f = besselJ, nu = 2.5, lower = 0, upper = 4.5)</code></pre>
<pre><code>## 1.118 with absolute error &lt; 1.4e-07</code></pre>
</div>
</div>
</div>
<div id="优化" class="section level2" number="3">
<h2><span class="header-section-number">3</span> 优化</h2>
<p>SciPy 的优化功能也不少，局部优化和全局优化问题，约束优化和无约束优化问题等都有涉及。下面是一个关于 5 维的香蕉函数的求极小值的问题。</p>
<p>笔者曾在书<a href="https://bookdown.org/xiangyun/data-analysis-in-action/">《R 语言数据分析实战》</a>专门整理了 <a href="https://bookdown.org/xiangyun/data-analysis-in-action/numerical-optimization.html">R 语言做数值优化</a>的问题，很全面，没啥要补充的，不在此一一对照。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>import numpy as np
from scipy.optimize import minimize

def rosen(x):
    &quot;&quot;&quot;The Rosenbrock function&quot;&quot;&quot;
    return sum(100.0*(x[1:]-x[:-1]**2.0)**2.0 + (1-x[:-1])**2.0)

x0 = np.array([1.3, 0.7, 0.8, 1.9, 1.2])
res = minimize(rosen, x0, method=&#39;L-BFGS-B&#39;)
               
print(res.x)               </code></pre>
<pre><code>## [0.99999957 0.99999915 0.99999834 0.99999667 0.99999336]</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>fn &lt;- function(x) {
  n &lt;- length(x)
  sum(100*(x[-1] - x[-n]^2  )^2 +  (1 - x[-n])^2 )
}
optim(
  par = c(1.3, 0.7, 0.8, 1.9, 1.2), fn = fn, 
  method = &quot;L-BFGS-B&quot;
)</code></pre>
<pre><code>## $par
## [1] 1.0000 0.9999 0.9999 0.9997 0.9994
## 
## $value
## [1] 1.007e-07
## 
## $counts
## function gradient 
##       27       27 
## 
## $convergence
## [1] 0
## 
## $message
## [1] &quot;CONVERGENCE: REL_REDUCTION_OF_F &lt;= FACTR*EPSMCH&quot;</code></pre>
</div>
</div>
</div>
<div id="稀疏数组" class="section level2" number="4">
<h2><span class="header-section-number">4</span> 稀疏数组</h2>
<p>稀疏数组应用很广泛，特别是在图关系数据（邻接矩阵）和文本数据分析（词文档矩阵）领域。下面是一个二维稀疏数组（即矩阵）的构造过程。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>import scipy as sp
import numpy as np
dense = np.array([[1, 0, 0, 2], [0, 4, 1, 0], [0, 0, 5, 0]])
sparse = sp.sparse.coo_array(dense)
dense</code></pre>
<pre><code>## array([[1, 0, 0, 2],
##        [0, 4, 1, 0],
##        [0, 0, 5, 0]])</code></pre>
<pre class="python"><code>sparse</code></pre>
<pre><code>## &lt;COOrdinate sparse array of dtype &#39;int64&#39;
## 	with 5 stored elements and shape (3, 4)&gt;</code></pre>
<pre class="python"><code>sparse.max()</code></pre>
<pre><code>## np.int64(5)</code></pre>
<pre class="python"><code>dense.max()</code></pre>
<pre><code>## np.int64(5)</code></pre>
<pre class="python"><code>sparse.argmax()</code></pre>
<pre><code>## 10</code></pre>
<pre class="python"><code>dense.argmax()</code></pre>
<pre><code>## np.int64(10)</code></pre>
<pre class="python"><code>sparse.mean()</code></pre>
<pre><code>## np.float64(1.0833333333333333)</code></pre>
<pre class="python"><code>dense.mean()</code></pre>
<pre><code>## np.float64(1.0833333333333333)</code></pre>
<pre class="python"><code>sparse.nnz</code></pre>
<pre><code>## 5</code></pre>
<pre class="python"><code>sparse.mean(axis=1)</code></pre>
<pre><code>## array([0.75, 1.25, 1.25])</code></pre>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<p>在 R 语言中，<strong>Matrix</strong> 包主要用于稀疏矩阵操作。</p>
<pre class="r"><code>library(Matrix)
dense = matrix(data = c(1, 0, 0, 2,
                        0, 4, 1, 0,
                        0, 0, 5, 0),
               byrow = T, nrow = 3, ncol = 4)
sparse = Matrix(dense, sparse=TRUE) 
dense</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    0    0    2
## [2,]    0    4    1    0
## [3,]    0    0    5    0</code></pre>
<pre class="r"><code>sparse</code></pre>
<pre><code>## 3 x 4 sparse Matrix of class &quot;dgCMatrix&quot;
##             
## [1,] 1 . . 2
## [2,] . 4 1 .
## [3,] . . 5 .</code></pre>
<pre class="r"><code>max(dense)</code></pre>
<pre><code>## [1] 5</code></pre>
<pre class="r"><code>max(sparse)</code></pre>
<pre><code>## [1] 5</code></pre>
<pre class="r"><code>which.max(dense)</code></pre>
<pre><code>## [1] 9</code></pre>
<pre class="r"><code># which.max(sparse)
mean(dense)</code></pre>
<pre><code>## [1] 1.083</code></pre>
<pre class="r"><code>mean(sparse)</code></pre>
<pre><code>## [1] 1.083</code></pre>
<pre class="r"><code>rowMeans(sparse)</code></pre>
<pre><code>## [1] 0.75 1.25 1.25</code></pre>
</div>
</div>
</div>
<div id="统计" class="section level2" number="5">
<h2><span class="header-section-number">5</span> 统计</h2>
<p>独立两样本方差相等的均值检验，即 t 检验，而在方差不等的情况下，是 Welch’s t-test 。</p>
<div class="columns">
<div class="column" style="width:47.5%;">
<pre class="python"><code>import scipy.stats as stats
rvs1 = stats.norm.rvs(loc=5, scale=10, size=500)
rvs2 = stats.norm.rvs(loc=8, scale=10, size=500)
stats.ttest_ind(rvs1, rvs2, equal_var=True)</code></pre>
<pre><code>## TtestResult(statistic=np.float64(-4.677832576759619), pvalue=np.float64(3.298043097151713e-06), df=np.float64(998.0))</code></pre>
<p>函数 <code>ttest_ind</code> 的参数说明见<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ttest_ind.html#scipy.stats.ttest_ind">文档</a>。</p>
</div><div class="column" style="width:5%;">
<p> 
<!-- an empty Div (with a white space), serving as
a column separator --></p>
</div><div class="column" style="width:47.5%;">
<pre class="r"><code>rvs1 = rnorm(n = 500, mean = 5, sd = 10)
rvs2 = rnorm(n = 500, mean = 8, sd = 10)
t.test(rvs1, rvs2, var.equal = TRUE)</code></pre>
<pre><code>## 
## 	Two Sample t-test
## 
## data:  rvs1 and rvs2
## t = -4.5, df = 998, p-value = 7e-06
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -4.102 -1.621
## sample estimates:
## mean of x mean of y 
##     5.625     8.487</code></pre>
</div>
</div>
<p>在 Python 和 R 语言中，都是随机生成的两组样本，样本并不相同，检验统计量的值、P 值等自然也不同。</p>
</div>
